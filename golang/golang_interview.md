# 先导

### Go语言的一些特性

##### 1. **高性能并发：原生协程（Goroutine）支持**

Go 在语言层面原生支持轻量级协程（Goroutine），由运行时高效调度。相比操作系统线程或进程，Goroutine 启动开销极小（初始栈仅约 2KB），可轻松创建数十万并发任务，以简洁的语法（`go func()`）实现高并发、高吞吐的网络服务，显著提升资源利用率和系统响应能力。

##### 2. **开发效率与运行性能兼得，编译极速**

Go 兼具接近 C 语言的执行效率与脚本语言（如 Python/PHP）般的开发体验。其静态编译模型无需虚拟机，生成单一可执行文件；同时编译速度极快——大型项目通常秒级完成，大幅缩短开发-调试循环，显著优于 Java、C++ 等传统编译型语言。

##### 3. **自动内存管理：低延迟垃圾回收（GC）**

Go 内置并发、三色标记清除式垃圾回收器，自 Go 1.18 起 STW（Stop-The-World）时间稳定控制在 **100 微秒以内**，兼顾内存安全与低延迟，开发者无需手动管理内存，专注业务逻辑即可。

##### 4. **卓越的跨平台能力**

Go 原生支持交叉编译，通过简单设置 `GOOS` 和 `GOARCH` 环境变量，即可从任意平台构建 Windows、Linux、macOS、ARM 等目标系统的可执行文件，真正做到“一次编写，随处部署”。

### Go语言和java之间的区别

- Go不支持方法重载，而java允许方法重载
- Go 在**启动速度、内存占用、高并发 I/O 场景**下通常优于 Java。
- Java 通过继承和接口显式实现多态；Go 通过隐式接口实现，更灵活。
- go语言的继承通过匿名组合完成，可实现多继承；而java的继承通过extends实现，不允许多继承

### Go语言和Python之间的区别

- python是一种动态类型语言，而go是一种静态类型语言。
- Python内部没有提供内置的并发机制，而golang有内置的并发机制。
- go允许用户管理内存，而python的内存管理完全自动化并由python vm管理，不允许程序员对内存负责
- python的语法使用缩进来指示代码块。Go的语法基于打开和关闭括号。

# 基础

### make和new的区别

##### 共同点：

- 都是用于分配内存

- 都是在堆上进行内存分配（误区）

  **注意：**Go 的编译器会通过 **逃逸分析（Escape Analysis）** 决定变量分配在栈上还是堆上。

  [Golang 内存调优 - 逃逸分析在计算机领域中，堆栈是非常重要的概念，数据结构中有堆栈，内存分配中也有堆栈；本该分配 - 掘金 (juejin.cn)](https://juejin.cn/post/7155815911755087908?searchId=20260118162209B5A9EC1392380AF88F7C)

##### 不同点：

- 作用变量类型不同，new可以给任意类型分配内存，make给切片，map和channel分配内存；
- 返回类型不一样，new返回指向变量的指针，make返回变量本身；
- new分配的空间被清零，make分配空间后会进行初始化。

### 常量和变量的区别

1. 变量是“可读、可写”，而常量是“只读”的

2. 变量在运行期分配存储内存（非优化状态）

   常量通常会被编译器在预处理阶段直接展开，作为指令数据使用

   数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址

### **for range 的时候它的地址会发生变化么？**

**Go1.22**之前，对于for range 循环中的迭代变量，其内存地址是不会发生变化的，之后的地址是临时的，是变化的，每次迭代时会重新生成迭代变量，这些变量在内存中是不同地址。

分析：

```Go
for index，value := range collection{
....///
}
```

这里value是一个副本。在每次迭代中，collection中的当前元素值会被复制到」value这个变量中。Go 编译器通常会为value分配一块固定的内存地址，然后在每次迭代时，将当前元素的值覆盖到这块内存中。所以，当你打印&value时，你会发现它的内存地址在整个循环过程中都是保持不变的。但是在Go1.23及以后，使用for range遍历一个集合时，迭代变量的地址会发生变化。这是因为for每次迭代时都会重新生成迭代变量（如value），这些变量在内存中是不同的地址。

### defer的执行顺序、作用、常用场景？

**执行顺序：**

每个defer都会对应一个defer实例，由链表构成底层数据结构，每次添加defer都会添加到链表的头部，输出也是从链表的头部开始执行，从而形成后入先出的效果。

**作用：**当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过return正常结束，还是由于 panic 导致的异常结束。

**常用场景：**打开、关闭，连接，断开连接，加锁，释放锁

**与返回值的交互：**

非命名返回值：return时会先将返回值拷贝到临时变量，defer修改局部变量不影响返回值。

命名返回值：返回值是函数作用域内的变量，defer可直接修改它，影响最终返回结果。

### 字符串

sring不可变，[]byte可变

#### byte 和 rune

byte等同于**uint8**，表示一个字节，常用来处理ascii字符

rune等同于**int32**，主要用于表示一个字符类型大于一个字节小于等于4个字节的情况下，常用来处理unicode或utf-8字符，特别是**中文字符。**

#### 字符串拼接

使用 + 拼接性能最差，strings.Builder，bytes.Buffer 相近，strings.Buffer 更快

![image-20230124203352486 ](https://camo.githubusercontent.com/7e65d699f762f54fbb4eee4e87b3fb2386481c23faeea5a92d8a02b49c3fe544/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f65623332653965383361333734386235383638376463613035343665396134347e74706c762d6b3375316662706663702d6a6a2d6d61726b3a333032343a303a303a303a7137352e6177656270)

原因：

- 字符串在 Go 语言中是不可变类型，占用内存大小是固定的
- 使用 + 每次都会重新分配内存
- strings.Builder，bytes.Buffer 底层都是 []byte
- 内存扩容策略，不需要每次拼接重新分配内存

### Tag和反射

[golang面试题：reflect（反射包）如何获取字段tag？为什么json包不能导出私有变量的tag？_golang面试题 反射tag-CSDN博客](https://blog.csdn.net/ilini/article/details/106755359#:~:text=本文介绍如何使用Golang的reflect包获取结构体中字段的tag信息，包括json和其他自定义tag，并通过实例演示了如何遍历结构体字段并打印出对应的tag内容。 json 包里使用的时候，会 结构体 里的字段边上加 tag，有没有什么办法可以获取到这个,tag 的内容呢？ tag 信息可以通过 反射（reflect包） 内的方法获取，通过一个例子加深理解。)

反射可以在==运行期间==，操作任意类型的对象。

可以通过`TypeOf`方法获得对象类型。通过`ValueOf`获得对象值。

Go 中解析的 tag 是通过反射实现的。

tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。

### Go函数参数传递方式

[【Go 进阶】Go 语言到底是值传递，还是引用传递？在 Go 语言中，函数的参数传递只有值传递，而且传递的实参都是原始数 - 掘金 (juejin.cn)](https://juejin.cn/post/7221730647043244090?searchId=20260118164706497C0410BD761A5E36CE)

#### **Go里面函数传参只有值传递一种方式**

> 值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
>
> 参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、channel等这些），这样就可以修改原内容数据。

> 所谓值类型：变量和变量的值存在同一个位置。
>
> 所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。
>
> 严格来说，Go 语言没有引用类型，但是可以把 map、chan 称为引用类型，这样便于理解。除了 map、chan 之外，Go 语言中的函数、接口、slice 切片都可以称为引用类型。
>
> > 指针类型也可以理解为是一种引用类型。

#### 什么情况下传入函数的切片更改不会影响到外部？

如果指向底层数组的指针被覆盖或者修改（copy、重分配、append触发扩容），此时函数内部对数据的修改将不再影响到外部的切片，代表长度的len和容量cap也均不会被修改。

### 深拷贝与浅拷贝

深拷贝：拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。

浅拷贝：拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。

值类型的数据，默认赋值操作都是深拷贝。

引用类型的数据，默认全部都是浅拷贝。

### Go语言中，空 struct{} 的作用

1、可以用map模拟一个set，然后用map的值可以设置为空结构体，空结构体本来不占任何空间。

2、作为值发送到Channel中

3、可以表示仅有方法的结构体

### Go中会出现Panic的场景

数组越界、空指针调用、除以0、关闭已关闭的通道、向已关闭的通道发送消息、关闭未初始化的通道、写未初始化的map、类型断言不匹配

### Go中下划线有什么作用？

匿名导入、忽略返回值

### init函数怎么执行的？

import –> const –> var –> init() –> main()

import : 由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。



### 多返回值怎么实现？

使用栈帧实现，在函数**被调用时**创建栈，**返回**时销毁，并用return返回存储在栈中的数据。如果要存储的数据规模比较大时会将其分配到堆上。 

Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。



### GO如如何实现类似于Java中的继承机制？

如果一个结构体嵌套了一个匿名结构体，那么这个结构可以直接访问匿名结构体的属性和方法，从而实现继承。

如果一个struct嵌套了另一个有名的结构体，那么这个模式叫做组合。

如果一个struct嵌套了多个匿名结构体，那么这个结构体可以直接访问多个匿名结构体的属性和方法，从而实现多继承。



### interface比较

interface 的内部实现包含了 2 个字段，**类型 T 和 值 V**

- 两个接口值比较时，**会先比较 T，再比较 V**。
- 接口值与非接口值比较时，**会先将非接口值尝试转换为接口值**，再比较。

2 个 interface 相等有以下2种情况：

1. 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
2. 类型 T 相同，且对应的值 V 相等。

```
func main() {
    var p *int = nil
    var i interface{} = p
    fmt.Println(i == p) // true
    fmt.Println(p == nil) // true
    fmt.Println(i == nil) // false
}
```

上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为`(T=*int, V=nil)`，i 与 p 作比较时，将 p 转换为接口后再比较，因此 `i == p`，p 与 nil 比较，直接比较值，所以 `p == nil`。

但是当 i 与 nil 比较时，会将 nil 转换为接口 `(T=nil, V=nil)`，与i `(T=*int, V=nil)` 不相等，因此 `i != nil`。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。

# slice

### 数组与切片的区别

1. **数组长度不同**

   数组初始化必须指定长度，并且长度就是固定的

   切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大

2. **函数传参不同**

   数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，函数传参操作都会复制整个数组数据，会占用额外的内存，函数内对数组元素值的**修改**，不会修改原数组内容。

   切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，函数传参操作不会拷贝整个切片，只会复制len和cap，底层共用同一个数组，不会占用额外的内存，函数内对数组元素值的**修改**，会修改原数组内容。

3. **切片不支持比较操作，数组内元素类型能比较就支持比较操作**



### 切片的数据结构

切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。

切片的长度（len）就是它所包含的元素个数。切片的容量（cap）是从它的第一个元素开始数，到其底层数组元素末尾的个数。

如果没有发生扩容，修改在原来的内存中，如果发生了扩容，修改会在新的内存中

**在复制 slice 的时候，slice 中数组的指针也被复制了，在触发扩容逻辑之前，两个 slice 指向的是相同的数组，触发扩容逻辑之后指向的就是不同的数组了**



### 扩容机制

GO1.17版本及之前

1. 当新切片需要容量 > 两倍的原容量时，直接使用期望容量作为新切片的容量。
2. 如果原容量 < 1024，那么新切片的容量变成原来的 2 倍。（避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价）
3. 如果原容量 >= 1024，进入一个循环，每次容量变成原来的1.25倍（实际上是不超过25%），直到大于期望容量。（主要避免空间浪费）

GO1.18之后

1. 当新切片需要容量 > 两倍的原容量时，直接使用期望容量作为新切片的容量。
2. 当原容量 < threshold，新 slice 容量变成原来的 2 倍。（threshold=256）
3. 当原容量 > threshold，进入一个循环，每次容量增加 (旧容量+3*threshold)/4，直到大于期望容量。



# map

### Map使用需要注意的点

1、key的唯一性：map中的每个key必须是唯一的。如果尝试使用已存在的key插入新值，则会覆盖旧值。

2、key的可比较性：作为key的类型必须是可比较的，这通常意味着它们应该是不可变的。例如，在Go语言中，切片、映射和函数类型因为包含可变状态，所以不能直接作为map的key。

**注意：这里为什么key要是可比较的？**

这是因为 map 在哈希冲突时（会在同一个桶里面），需要通过 `==` 来精确比对 key，确保操作的是正确的键值对。首先，Map会对我们提供的Key进行哈希运算，得到一个哈希值。这个哈希值决定了这个键值对大概存储在哪个位置（也就是哪个"桶"里）。然而，不同的Key可能会产生相同的哈希值，这就是"哈希冲突"。当多Key被定位到同一个"桶"里时，Map就没法只靠哈希值来区分它们了。此时，它必须在桶内进行逐个遍历，用我们传入的Key和桶里已有的每一个Key进行**相等（==）**比较。这样才能确保我们操作的是正确的键值对。

3、初始化和nilmap：声明一个map变量不会自动初始化它。未初始化的map变量的零值是nil，对nil map进行读写操作会引发panic。

**注意：这里初始化的map和nil map有什么不同？**

- **nil map**：未初始化的map的零值是nil。这意味着map变量被声明后，如果没有通过make函数或其他方式显式初始化，它将保持nil状态。nil map不占用实际的内存空间来存储键值对，因为它没有底层的哈希表结构。（赋值会panic，其他不会）
- **空map**：空map是通过make函数或其他方式初始化但没有添加任何键值对的map。空map已经分配了底层的哈希表结构，但表中没有存储任何键值对。因此，空map占用了一定的内存空间，尽管这个空间相对较小。

4、遍历顺序：map的遍历顺序是不确定的。

5、并发安全性：不是并发安全的。

### Map的并发安全性

- Go语言中的map类型并不是并发安全的。这意味着，如果有多个goroutine尝试同时读写同一个map，可能会导致竞态条件和数据损坏。
- 为了在并发环境下安全地使用map，可以采取以下几种策略：
  1. **使用互斥锁（sync.Mutex）**：在读写map的操作前后加锁，确保同一时间只有一个goroutine可以访问map。
  2. **使用读写互斥锁（sync.RWMutex）**：如果读操作远多于写操作，可以使用读写锁来提高性能。读写锁允许多个goroutine同时读取map，但在写入时需要独占访问。
  3. **使用并发安全的map（sync.Map）**：从Go 1.9版本开始，标准库中的sync包提供了sync.Map类型，这是一个专为并发环境设计的map。它提供了一系列方法来安全地在多个goroutine之间共享数据。

### **Map的Key为什么无序**？

- **动态扩容**导致键值对的存储位置发生偏移；
- 遍历时**生成随机数**确定开始遍历的位置；
- 使用**哈希函数**存储键值对，导致无序。

### Map如何实现顺序读取？

**常见做法：**

如果业务上确实需要有序遍历，最规范的做法就是将Map的键（Key）取出来放入一个**切片（Slice）**中, 用**sort 包**对切片进行排序（nlogN），然后根据这个有序，的切片去遍历Map。

**缺点：**这种方法不适合“读多写少”的场景

**更有效的方法：**

1、使用平衡二叉搜索树来代替map，树的每个节点存放键值。插入、删除、查找等操作时间复杂度都是O（logN)（这个是需要排序）

2、用list和map的组合实现，map用于存储数据，保证按O(1)进行查找、插入和删除。list用于维护插入顺序，当我们插入新元素时，把键放入list中，保证顺序性。

### **Map相等的条件**

（1）都为nil；

（2）长度相等；对应的k和v类型和值都相等

（3）长度相同不为空，指向同一个Map实体

### **是否可以对Map的元素取地址**

不可以，由于Map会进行动态扩容，扩容后键值对的位置会发生改变，那么该地址对应的值也会发生改变。

### 删除一个Key值，对应的Value的内存会被释放吗？对应map的内存会变小吗？

在 Go 中，当我们从 map 中删除一个 key（比如 `delete(m, key)`），只是断开了 map 对这个 value 的引用。

之后，这个 value 是否会被释放，取决于它是否还有其他地方被引用：

- 如果没有其他变量、指针或数据结构引用它，那么**它就变成“不可达对象”**，会在下一次垃圾回收（GC）时被自动回收；
- 如果还有其他引用（比如之前把它赋值给了另一个变量），那它就不会被回收。

对应map内存不会变小，它只是把key和value对应的内存块标记为“空闲“，桶的规模是不会缩小的。内存的释放取决于GO语言的垃圾器何时触发回收过程。



### Map的数据结构是什么？

map的就是一个hmap的结构。Go Map的底层实现是一个哈希表。它在运行时表现为一个指向hmap 结构体的指针，hmap中记录了桶数组**指针buckets、溢出桶指针以及元素个数**等字段。每个桶是一个**bmap**结构体，能存储8个键值对和8个tophash，并有指向下一个溢出桶的指针***overflow***。为了内存紧凑，bmap中采用的是先存8个键再存8个值的存储方式。

```
type hmap struct {
    count     int                  // 元素个数
    flags     uint8
    B         uint8                // B是buckets数组的长度的对数 2^B表示桶数量
    noverflow uint16               // 溢出的bucket个数
    hash0     uint32               // hash seed

    buckets    unsafe.Pointer      // 桶
    oldbuckets unsafe.Pointer      // 旧桶
    nevacuate  uintptr             // 即将迁移的旧桶编号

    extra *mapextra                // 用于扩容的指针
}
```

![img](https://camo.githubusercontent.com/63346ab5641ad6f63d6dfae293e1d25166bce4372ddf2687a901494e4ba01b36/68747470733a2f2f696d6167652d313330323234333131382e636f732e61702d6265696a696e672e6d7971636c6f75642e636f6d2f696d6763646e2f3634302e706e67)



### map出现哈希冲突会怎么样？

发生哈希冲突会用链地址法，当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用**链地址法**来解决键冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个桶，用类似链表的方式将bucket连接起来。bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，**好的哈希算法**可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。



### 扩容机制

1. 负载因子 = 哈希表存储的元素个数 / 桶个数（count/2^B^）> 6.5，触发双倍扩容
2. 溢出桶太多，触发等量扩容

增量扩容

当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。
考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用**逐步搬迁策略**，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。

等量扩容

所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。



### 查找过程

查找过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 取哈希值高位在tophash数组中查询
4. 如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较
5. 当前bucket没有找到，则继续从下个overflow的bucket中查找。
6. 如果当前处于搬迁过程，则优先从oldbuckets查找

注：如果查找不到，也不会返回空值，而是返回相应类型的0值。

### 插入过程

新元素插入过程如下：

1. 根据key值算出哈希值
2. 取哈希值低位与hmap.B取模确定bucket位置
3. 查找该key是否已经存在，如果存在则直接更新值
4. 如果没找到将key，将key插入

### **Sync.Map的用法**

Map在并发读写操作中可能会报出panic异常，因为它不是并发安全的。如果想要保证并发安全可以使用Sync.Map。它可以直接使用而不需要初始化，使用**Load()获取数据、Store()添加数据、Delete()删除数据**；不支持长度查询，需要手动遍历计算长度；可以使用range进行遍历，需要使用匿名函数和接口类型的k、v来接收数据。单线程中或低并发使用Map效率更高，多线程或高并发中使用Sync.Map更安全（防止数据竞争，保证同步）。

### Sync.Map底层原理

sync.Map里有两个map一个是专门用于读的read map，另一个是提供读写的dirty map；优先读read map，若不存在则加锁穿透读dirty map，同时记录一个未从read map读到的计数，当计数到达一定值，就将read map用dirty map进行覆盖。

优点：通过读写分离，降低锁时间来提高效率。

缺点：不适用于大量写的场景，这样会导致read map读不到数据而进一步加锁读取，同时dirty map也会一直晋升为read map，整体性能较差。

适用场景：大量读，少量写。存在大量写的场景可以考虑map+metux。

### dirtymap怎么覆盖or更新旧的readmap的？

1. 写请求过来时，先对 `dirtymap` 加互斥锁（保证同一时间只有一个写操作能修改它，避免并发写冲突）。
2. 在 `dirtymap` 里执行具体操作：新增键值对、修改已有键的值，或删除某个键。
3. 当需要把 `dirtymap` 的数据同步到 `readmap` 时（比如达到一定更新次数、定时同步等触发条件）：
   1. 新建一个空的 map 实例（叫 “新只读 map”）。
   2. 把 `dirtymap` 里所有的键值对，完整复制到这个 “新只读 map” 中（关键：不是复制指针，是复制数据，避免 `readmap` 和 `dirtymap` 指向同一数据）。
   3. 通过 `atomic.StorePointer` 原子操作，把 `readmap` 的指针 “瞬间切换” 到这个 “新只读 map” 上（读操作无感知，切换过程不阻塞读）。
4. 同步完成后，清空 `dirtymap` 里的所有数据，重置相关计数（比如更新次数、脏数据标记）。
5. 释放 `dirtymap` 的互斥锁，允许下一个写操作进来。

# Channel

### 什么是channel？

channel是一种**通信机制**，可以满足**多线程****之间的通信和同步**，允许一个Goroutine利用Channel向另一个Goroutine发送数据，可以理解为一个管道，是并发安全的，可以使用Close()关闭。

### channel的数据结构

[Go面试题(五):图解 Golang Channel 的底层原理channel是golang中用来实现多个gorouti - 掘金](https://juejin.cn/post/7037656471210819614)

Channel底层是一个名为hchan的结构体，核心包括几个关键组件：

1、**环形缓冲区**：有缓冲channel内部维护一个固定大小的环形队列，用buf 指针指向缓冲区,sendx 和recvx 分别记录发送和接收的位置索引。

2、**两个等待队列sendq和recvq**:用来管理阻塞的Goroutine。sendq 存储因channel满而阻塞的发送者，recvq 存储因channel空而阻塞的接收者。这些队列用**双向链表**实现，当条件满足时会唤醒对应的goroutine。

3、**互斥锁**：所有的发送、接收操作都需要先获取锁，用来保证并发安全。

**怎么加锁的？**

例如，初始hchan结构体的buf为空，sendx和recvx均为0。

当G1向ch里发送数据时，首先会对buf加锁，然后**将数据copy到buf中**，然后sendx++，然后释放对buf的锁。

当G2消费ch的时候，会首先对buf加锁，然后将buf中的**数据copy到task变量对应的****内存****里**，然后recvx++,并释放锁。

### **讲讲 Go 的 chan 主要使用场景**

**无缓冲和有缓冲区别：** 无缓冲 channel（`make(chan T)`）容量为 0，发送和接收必须同时就绪，是强同步的，常用于 goroutine 间的精确协调；而有缓冲 channel（`make(chan T, N)`）内部有容量为 N 的缓冲区，只要未满发送不阻塞、非空接收不阻塞，能提升吞吐和解耦生产消费，但本质上仍是同步通信——缓冲区满或空时仍会阻塞，并非真正异步。
**channel 的一些特点** 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic
**向 channel 写数据的流程：** 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；
**向 channel 读数据的流程：** 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；
**使用场景：** 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步



### Select使用及其实现原理

为I/O提供的一种多路复用技术，select语句的每条case是一个channel，select会随机选择一条分支判断是否满足条件，满足则执行；否则挑选另一条分支；都不满足会执行default分支，这使得select分支永远不会阻塞。

```
Go语言实现 select 时，定义了一个数据结构scase表示每个case 语句(包含 default ）。scase结构包含channel指针、操作类型等信息。select操作的整个过程通过selectgo函数在runtime层面实现。Go运行时会将所有case进行随机排序，这是为了避免饥饿问题。然后执行两轮扫描策略：第一轮直接检查每个channel是否可读写，如果找到就绪的立即执行；如果都没就绪，第二轮就把当前goroutine加入到所有channel的等待队列中，**然后调用gopark进入阻塞状态，使当前goroutine让出CPU。**当某个channel变为可操作时，调度器会唤醒对应的goroutine，此时需要从其他channel的等待队列中清理掉这个goroutine，然后执行对应的case分支。
```

其核心原理是：case随机化+双重循环检测



# context

### Go语言里的Context是什么？

**context 主要用来在 goroutine 之间传递上下文信息，包括：取消信号、超时时间、截止时间、k-v 等。**

context实际上是一个接口，提供了**Deadline(),Done(),Err()以及Value()**四种方法。

Deadline() 会返回一个时间点，告知任务何时被取消。

Done()返回一个channel，当context被取消或超时，这个channel会关闭。

Err（）解释channel关闭的原因，是主动取消还是超时。

Value（）允许Context在调用链中携带请求范围的键值对数据。

### Go语言中的Context有什么作用？

三个核心作用：超时控制、取消信号、请求级数据传递。

超时控制可以使用context.withTimeout()创建ctx实现，当操作超过设定的时间时，所有子操作会收到取消信号并立即退出。

- 例如，在数据库查询或网络请求时，可以使用 `context` 设置一个超时时间，以防止长时间的等待。

取消信号可以使用context.WithCancel()创建一个可取消的上下文，会返回一个cancel函数，调用这个函数会发送取消信号。

- 例如，在处理 HTTP 请求时，如果客户端关闭了连接，可以使用 `context` 取消所有相关的后台操作。

Context能携带一定的键值在ctx中进行传递。

- 例如，在处理 HTTP 请求时，可以将请求的元数据存储在 `context` 中，并在各个处理函数之间传递这些数据。

### context如何被取消？

context取消主要通过channel关闭信号实现的，主要有三种取消方式。

首先是**主动取消**，通过 context.Withcancel 创建的Context会返回一个cancel函数，调用这个函数就会关闭内部的done channel，所有监听这个Context的goroutine都能通过 ctx.Done（）收到取消信号。
其次是**超时取消**，context.WithTimeout和context.WithDeadline会启动一个定时器，到达指定时间后自动调用cancel函数触发取消。
最后是**级联取消**，当父Context被取消时，所有子Context会自动被取消，这是通过Context树的结构实现的。

### 常用函数

- `context.Background()`: 返回一个空的 `Context`，通常用于根 `Context`。
- `context.TODO()`: 返回一个空的 `Context`，用于暂时不知道该使用什么 `Context` 的情况。
- `context.WithCancel(parent Context) (Context, CancelFunc)`: 创建一个可以取消的 `Context`。
- `context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`: 创建一个带超时的 `Context`。
- `context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)`: 创建一个带截止时间的 `Context`。
- `context.WithValue(parent Context, key, val interface{}) Context`: 创建一个携带值的 `Context`。



# 锁

### 除了 mutex 以外还有那些方式安全读写共享变量？

信号量，通道，原子操作

### Go 语言是如何实现原子操作的？

依赖于底层的CPU硬件提供的原子指令，而不是通过操作系统或更上层的锁机制。

### 聊聊原子操作和锁的区别？

原子操作是保证对**单个数据的单次读改写操作**，是绝对不可分割的，性能极高，因为它不涉及操作系统内核的介入和Goroutine的挂起。

锁保护的一个代码块，而不是仅仅单个变量。当获取锁失败时，会让Goroutine休眠，而不是空耗CPU。

### Go语言互斥锁mutex底层是怎么实现的？

底层是通过原子操作和信号量实现的，通过**原子操作来实现锁的锁定**，**通过信号量来实现协程的阻塞与唤醒。**互斥锁底层对应的结构是sync.mutex结构体。state表示**锁的状态**，有**锁定、被唤醒、饥饿模式**等，并且是state的**二进制位**来标识的，sema表示信号量，用来实现**mutex****阻塞队列的定位**，从而实现Goroutine的阻塞和唤醒。

### Mutex 有几种模式？

**正常模式：**新请求的Goroutine会与等待队列头部Goroutine进行竞争，新来的Goroutine会进行几次**自旋，如果在此期间锁被释放，它就可以直接抢到锁。这种方式**吞吐量****高**，但可能会导致头部的Goroutine等待很久。

**饥饿模式：**当一个Goroutine在等待队列等待超过1毫秒后就会进行这种模式，它会将锁直接交给等待队列头部的Goroutine，新来的Goroutine只能去往等待队列的尾部。

当等待队列为空，或者一个Goroutine拿到锁时发现它的等待时间小于1ms，饥饿模式就会结束，切换正常模式。

### sync.Once 的作用是什么，它和WaitGroup有什么区别？

sync.Once 的作用是确保**某个函数**在程序整个生命周期内，无论是在多少个Goroutine内被调用，它只会被执行一次，常用于**单例****对象的初始化或一些只需要执行一次的全局配置加载**。**WaitGroup用于等待一组 goroutine 全部执行完毕，常用于协调并发任务的结束。**

### 讲一下sync.Once的底层原理？

sync.Once底层其实维护了一个标识位，当这个标识位为0时，说明还未被执行过函数。此时加锁修改标识位为1，然后执行相应函数。后续再执行时会判断这个标识位不为0然后不再执行后续操作。

### WaitGroup是怎么实现协程等待的？

WaitGroup 实现等待，本质上是一个**原子计数器**和一个**信号量**的协作。

调用 Add 会增加计数值，Done 会减计数值。而 Wait 方法会检查这个计数器，如果不为零，就利用**信号量**将**当前goroutine高效地挂起**。直到最后一个Done调用将计数器清零，它就会通过这个信号量，一次性唤醒所有在Wait处等待的goroutine，从而实现等待目的。

### **讲一下sync.pool**

sync.pool是Go语言在标准库包中提供的一个类型，他主要用于存储和复用临时对象，**以减少内存分配的开销，提高性能。**当你需要一个新的对象时，可以先从sync.pool中尝试获取，如果有可用的的对象，则直接返回该对象；如果没有就需要自行创建。使用完对象后，可以将其放回sync.pool中，以供后续再次使用。

**主要特点：**

1. 减少内存分配和GC压力。
2. 并发安全。
3. 自动清理：go的垃圾回收在每次垃圾回收时，都会清除sync.pool中的所有对象。

**使用场景：**

- 对象实例创建开销较大的场景，如数据库连接、大型数据结构等。
- 需要频繁创建和销毁临时对象的场景，如 HTTP 处理函数中频繁创建和销毁的请求上下文对象。

**使用方法：**

创建pool实例，获取对象（get），使用对象，放回对象（put)。

**注意事项：**

1. **对象状态未知**：从`sync.Pool`中获取的对象的状态是未知的。因此，在使用对象之前，你应该将其重置到适当的初始状态。
2. **自动清理**：由于 Go 的垃圾回收器会清理 `sync.Pool` 中的对象，因此你不能依赖 `sync.Pool` 来长期存储对象。
3. **不适合所有场景**：`sync.Pool` 并不适合所有需要对象池的场景。特别是对于那些需要精确控制对象生命周期的场景，你可能需要实现自定义的对象池。

### 什么是自旋锁？

自旋锁是指当一个线程（在 Go 中是 Goroutine）在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待（自旋），不断判断锁是否已经被释放，而不是进入睡眠状态。这种行为在某些情况下可能会**导致资源的过度占用**，特别是**当锁持有时间较长或者自旋的 Goroutine 数量较多时。**



# GMP相关

### Go语言中的GMP模型是什么？

GMP是go运行时核心调度模型，G是Goroutine协程，M是machine系统线程，P是调度器，P是G和M之间的桥梁，负责调度G。调度逻辑是，M必须绑定P才能执行G。每个P维护一个自己的本地队列，M从P的本地队列取G执行。当本地队列为空时，M会按优先级从全局队列、网络轮询器、其他P队列中窃取Goroutine。

### GMP的作用是什么？

1. 实现Goroutine的**高效调度**
2. 充分利用**多核CPU**资源
3. **减少锁竞争**，提升调度效率
4. 处理阻塞场景，**避免资源浪费**

## 调度流程是什么样的？

1. **创建 Goroutine**：
   1. 当通过 `go func()` 创建新的 Goroutine 时，G 会首先被加入到与当前 P 关联的本地队列中。
   2. 如果 P 的本地队列已满（超过 256 个 G），则新的 G 会被放入全局队列。
2. **调度与执行**：
   1. 每个 M 与一个 P 绑定，M 从 P 的本地队列中获取一个 G 来执行。
   2. 如果 P 的本地队列为空，M 会尝试从全局队列或其他 P 的本地队列中偷取（work stealing）任务执行。
3. **系统调用与阻塞**：
   1. 当 G 执行过程中发生阻塞或系统调用，M 也会被阻塞。这时，P 会解绑当前的 M，并尝试寻找或创建新的 M 来继续执行其他 G。
   2. 阻塞结束后，原来的 M 会尝试重新绑定一个 P 继续执行。

**关键机制：**

**work stealing（工作量窃取） 机制**：会优先从全局队列里进行窃取，之后会从其它的P队列里窃取一半的G，放入到本地P队列里。 **hand off （移交）机制**：M 被阻塞时，P 会被移交给其他空闲的 M，或者创建新的 M 来执行任务。

## Goroutine什么情况下会阻塞？

1. **由于原子、****互斥****量或通道操作调用导致 Goroutine 阻塞**，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine;
2. **由于网络请求和** **IO** **操作导致 Goroutine 阻塞**。Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其后台通过kqueue（MacOS），epoll（Linux）或iocp（Windows）来实现IO多路复用。通过使用NetPoller 进行网络系统调用，调度器可以防止Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，网络轮询器使用系统线程，它时刻处理一个有效的事件循环，有助于减少操作系统上的调度负载。用户层眼中看到的Goroutine 中的"block socket"，实现了 goroutine-per-connection 简单的网络编程模式。实际上是通过 Go runtime 中的 netpoller 通过Non-block socket + I/O 多路复用机制"模拟"出来的。
3. **当调用一些系统方法的时候（如文件****I/O****）**，如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 G1 将阻塞当前 M1。调度器引I入 其它M 来服务 M1 的P。
4. **如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。**Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。

## G有哪些状态？

空闲、可运行、运行中、等待中、系统调用中、已退出。

## Go语言在进行goroutine调度的时候，调度策略是怎样的？

1. 主动调度：由用户调用函数发起，Goroutine由running变为runnable并被放到全局运行队列
2. 被动调度：由于互斥锁或通道阻塞等原因，Goroutine由running变为runwait，随后等待被唤醒
3. 正常调度：一个Goroutine执行结束调度另一个Goroutine执行
4. 抢占调度：防止单个G长时间占用CPU

1）基于协作的抢占式调度

 **这种调度方式主要是通过函数调用来实现的**，在编译期，**编译器**会在几乎所有的函数调用的入口处，插入一小段检查代码。这段代码会检查当前goroutine是否已经被标记为**需要被抢占**。如果是，当 G 进行函数调用时，G 会检查自己的标志，如果它为 true,则它将自己与 M 分离并推入goroutine的全局队列，抢占完成。

2）基于信号的抢占式调度

sysmon会检测到运行了10ms以上的G（goroutine）。然后，sysmon 向运行G的M发送信号。**Go的信号处理程序**会调用M上的一个叫作 gsignal 的 goroutine 来处理该信号，并使其检查该信号。gsignal 看到抢占信号，停止正在运行的G。

## 发生调度的时机有哪些？

等待读取或写入无缓冲的通道

等待互斥锁释放

由于time.sleep()而等待

发生系统调用

## 为什么要有P？

GMP中的P层理论上可以去掉，但会带来严重的性能问题。

掉P的后果：如果直接变成GM模型，所有M都需要从全局队列中获取goroutine，这就需要全局锁保护。

在高并发场景下，大量M争抢同一把锁会造成严重的锁竞争，CPU大部分时间都浪费在等锁上，调度效率

急剧下降。

P层的价值：P的存在**实现了无锁的本地调度**。每个P维护独立的本地队列，M绑定P后可以直接从本地队列

取G执行，大部分情况下都不需要全局锁。只有本地队列空了才去偷取，这大大减少了锁竟争。

这里为什么全局队列需要锁，本地队列不需要？

- 全局队列：被所有 P 和 M 共享，存在多生产者、多消费者的并发竞争，必须通过全局锁保证安全。
- 本地队列：仅被绑定的 P 和 M 访问，属于 “单线程操作” 场景，无并发竞争，因此无需加锁。

## 什么是m0？

M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责**执行初始化操作和启动**第一个G， 在之后M0就和其他的M一样了。

## 什么是g0？

G0是每次启动一个M都会第一个创建的goroutine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。

#### G,P,M 的个数问题：

**G（Goroutine）的个数**

- **理论上无限制**：G的数量在理论上是没有上限的，只要系统的内存足够，就可以创建大量的goroutine。这是因为goroutine比线程更轻量级，它们共享相同的地址空间，并且在堆上分配的内存相对较少。
- **实际受内存限制**：尽管理论上goroutine的数量没有限制，但实际上它们会受到系统可用内存的限制。每个goroutine都需要分配一定的栈空间（尽管栈的大小可以动态调整），而且goroutine之间共享的数据结构（如全局变量、通道等）也会占用内存。

**P（Processor）的个数**

- **通常设置为逻辑CPU数的两倍**：P的数量通常建议设置为逻辑CPU核心数的两倍，这是为了提高调度的并行性和效率。每个P都可以绑定到一个M上执行goroutine，而设置更多的P可以使得在某些M阻塞时，其他M仍然可以执行P上的goroutine，从而减少等待时间。
- **由**`**<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">GOMAXPROCS</font>**`**决定**：P的实际数量由环境变量`<font style="color:#DF2A3F;background-color:rgb(253, 253, 254);">GOMAXPROCS</font>`（或在Go程序中通过`<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">runtime.GOMAXPROCS</font>`函数设置）决定。这个值限制了同时运行的goroutine的数量，即在任何给定时间，最多只有`<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">GOMAXPROCS</font>`个goroutine在CPU上执行。

**M（Machine/Thread）的个数**

- **动态创建和销毁**：M的数量是动态变化的，Go运行时根据需要创建和销毁M。当一个M上的所有goroutine都阻塞时，该M可能会被销毁，而当有goroutine等待执行但没有可用的M时，会创建新的M。
- **默认和最大限制**：Go程序启动时，会设置一个M的最大数量（默认通常是10000，但这个值可能因Go版本和操作系统而异），但这个限制很少达到，因为操作系统本身就有线程/进程数量的限制。此外，通过`<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">runtime/debug</font>`包中的`<font style="color:rgb(5, 7, 59);background-color:rgb(253, 253, 254);">SetMaxThreads</font>`函数可以设置M的最大数量，但这个函数主要用于调试目的，不建议在生产环境中随意更改。
- **与P的关系**：M与P之间没有绝对的固定关系。一个M可以绑定到任意P上执行goroutine，而当M阻塞时，它会释放其绑定的P，P随后会尝试绑定到其他空闲的M上。因此，即使P的数量较少，也可能因为工作量窃取和M的动态创建而有大量的M存在（尽管这些M中的大多数可能在等待中）。



# 内存管理

### 知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？

- 如果变量只在当前函数内使用，且不会被外部引用 → 分配在栈上（高效，随函数退出自动释放）
- 如果变量的生命周期超出当前函数（“逃逸”了）→ 分配在堆上（由 GC 管理）

内存逃逸是编译器在程序编译时期根据逃逸分析策略，将原本应该分配到栈上的对象分配到堆上的一个过程。

主要场景：

**返回****局部变量****指针：**函数返回内部变量的地址，变量必须逃逸到堆上

**闭包引用外部变量：**被闭包捕获的变量会逃逸到堆上

**切片/map动态扩容：**当容量超出编译期确定范围时会逃逸

**大对象：**超过栈大小限制的对象直接分配到堆上

### 内存逃逸有什么影响？

因为堆对象需要垃圾回收机制来释放内存，栈对象会跟随函数结束被编译器回收，所以大量的内存逃逸会给gc带来压力

### 什么是内存泄漏？原因有哪些？

一个引用数据被错误地留在内存中导致GC无法正常回收。

场景：

**goroutine泄漏：**goroutine没有正常退出会一直占用内存，比如从channel读取数据但channel永远不会有数据写入，或者死循环没有退出条件。

**channel****泄漏：**比如生产者已经结束但没有关闭channel，消费者goroutine会一直阻塞等待，造成内存无法回收。

**slice引用大数组：**当slice引用一个大数组的小部分时，整个底层数组都无法被GC回收。

**map元素过多：**map中删除元素只是标记删除，底层bucket不会缩减。

**定时器未停止：**time.After 或 time.NewTimer 创建的定时器如果不手动停止，会在heap中持续存在。

**循环引用：**虽然Go的GC能处理循环引用，但在某些复杂场景下仍可能出现问题。

###  Channel是分配在栈上，还是堆上？

channel分配在堆上，Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某

个函数内部，所以一般情况下golang 直接将其分配在堆上

### go语言发生了内存泄漏如何定位和优化？

**定位工具：**pprof、trace、runtime统计

**定位方法：**先看内存增长曲线，如果内存持续上涨不回收，就用pprof分析哪个函数分配内存最多。如果是Goroutine泄漏，会看到Goroutine数量异常增长，然后分析这些Goroutine阻塞在哪里。

**常见优化手段：**

Goroutine泄漏：使用Context设置超时，确保Goroutine有退出机制，避免无限阻塞。

channel泄漏：及时关闭channel，使用select + default避免阻塞。

定时器清理：手动调用timer.Stop()释放资源

slice引用优化：对大数组的小slice使用copy创建独立副本

# 垃圾回收GC

[Go面试题(六):一文弄懂 Golang GC、三色标记、混合写屏障机制【图文解析GC】面试官上来就让我讲讲Golang - 掘金](https://juejin.cn/post/7040737998014513183)

### **讲一下Golang中的****垃圾回收****机制？（1.5——1.7版本）**

Golang中的GC采用三色标记清除法+写屏障来提高效率。

传统的标记-清除法需要在标记和清除阶段进入STW导致延迟很高，所以GO引入了并发的三色标记清除法+写屏障。

首先将所有的对象分为白灰黑三种类型。**白色为未被访问**，垃圾回收结束后白色对象会被清理；灰色为已被访问但其引用对象还未完全扫描的对象，待处理队列；黑色是已被访问且其所有引用对象都已被扫描完成的对象，确认存活。

GC开始时，所有对象初始化为白色，随后从根对象触发，将直接可达的对象标记为灰色，并放入灰色队列。接着从灰色队列中取出对象，将其标记为黑色，并遍历其引用的子对象；若子对象仍为白色，则将其标记会灰色，放入灰色队列。此过程持续进行，直到灰色队列为空，最后回收白色的对象。但这个过程仍存在一个问题，即如果**黑色对象新增指向白色对象，由于黑色对象不会再被扫描，该白色对象可能无法被标记导致被误删。**为解决这一情况，Golang引入写屏障，在标记阶段，每当程序执行指针赋值操作，写屏障会自动检查被赋值的指针目标。如果目标对象是白色，则立即将其标记为灰色，确保其不会被遗漏。

### Go语言GC的根对象有哪些？

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1.**全局变量：**程序在编译期就能确定的那些存在于程序整个生命周期的变量。

2.**执行栈****：**每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块

的指针。

3.**寄存器：**寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

### **GC****的流程是什么样的？**

Go 的垃圾回收采用并发三色标记-清除算法，整体分为四个阶段：

（1）标记准备（STW）：暂停所有 goroutine，开启写屏障，并扫描根对象（如 goroutine 栈和全局变量），将直接可达对象标为灰色；

（2）并发标记：后台 worker 与用户程序并发执行三色标记，写屏障确保在指针赋值时，若目标对象为白色则立即将其标灰，防止漏标；

（3）标记终止（STW）：再次短暂停，关闭写屏障，完成剩余标记和状态同步；

（4）并发清除：由内存分配器在需要时惰性触发，回收已标记为垃圾的内存块，供后续复用。

整个过程仅有两次极短的 STW（通常 < 100 微秒），通过并发和写屏障实现低延迟，适用于高并发服务场景。

### **创建多个小对象会为GC带来压力？**

（1）多个小对象导致**内存碎片化**，增加GC对对象的标记和清除压力；

（2）小对象分布到各处，不利于标记；重复的分配回收导致GC也需重复标记和清除，增加GC压力。

### **GC的触发条件or时机有哪些？**

主动触发：通过runtime.GC（）来触发GC

被动触发：1、go后台有一系统监控线程，当超过**两分钟**没有产生任何GC时，强制触发GC。

2、**内存扩大一倍**的使用时会启动GC。