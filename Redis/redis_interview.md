# 概述

### Redis是什么？简述它的优缺点？

edis本质上是一个**Key-Value类型的内存数据库**，很像Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存。 **因为是纯内存操作**，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value 数据库。 

**优点**：

- 读写性能极高， Redis能读的速度是110000次/s，写的速度是81000次/s。
- 支持数据持久化，支持AOF和RDB两种持久化方式。
- 支持事务， Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
- 数据结构丰富，除了支持string类型的value外，还支持hash、set、zset、list等数据结构。
- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
- 丰富的特性 – Redis还支持 publish/subscribe， 通知， key 过期等特性。

**缺点**：

- 数据库容量受到**物理内存的限制**，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
- **主机宕机，宕机前有部分数据未能及时同步到从机**，切换IP后还会引入数据不一致的问题，降低了系统的可用性。

### Redis为什么快？

- 所有数据在**内存**，读写纳秒级；
- **单线程**避免了锁竞争和上下文切换，反而更高效；
- 底层用跳表、压缩列表、哈希表等结构，操作基本是 **O(1) 或 O(****log** **n)**；
- 用 epoll（Linux）实现 **I/O** **多路复用**，一个线程扛住数万并发。

epoll多路复用讲一下？

I/O多路复用就是使用一个线程来检查多个Socket的就绪状态，在单个线程中通过记录跟踪每个Socket（I/O流）的状态来管理处理多个I/O流。以Redis的I/O多路复用程序epoll函数为例。多个客户端连接服务端时，Redis会将客户端socket 对应的**文件描述符**注册进 epoll，然后 epoll 同时监听多个文件描述符(FD)是否有数据到来，如果有数据来了就通知**事件处理器**赶紧处理，这样就不会存在服务端一直等待某个客户端给数据的情形。

### Redis相比Memcached有哪些优势？

- 数据类型：Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。
- 持久化：Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储 。
- 集群模式：Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
- 性能对比：Redis的速度比Memcached快很多。
- 网络IO模型：Redis使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞IO模式。
- Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。

### Redis的基本数据类型有哪些？

### String

string数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

### List

列表支持存储一组数据，这种数据类型对应两种实现方法：一种是压缩列表，另一种是双向循环链表。

压缩列表用于存储数据量较小的情况，需要满足两个条件：

- 列表中的单个数据要小于 64 字节。
- 列表中的数据个数少于 512 个。

压缩列表可以支持不同类型数据的存储。而且它使用了连续的存储空间，读取效率非常高，但**无法实现使用数组下标随机访问的特性**。

双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

应用场景：微博的关注列表，粉丝列表， 消息列表等功能

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

### Hash

字典用于存储一组数据对，每个数据对都包含键和值两个部分。字典类型也有两种实现方式：**压缩列表** 和 **哈希表**。

### Set

集合用于存储一组不重复的数据。这种数据类型也有两种实现方法：**有序数组（整数集合） 和 哈希表**。

当数据较少时，使用有序数组进行存储，使用条件为：

- 存储的数据都是整数
- 存储的数据元素个数不超过 512 个

set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：`sinterstore key1 key2 key3`将交集存在key1内。

### Sorted Set（ZSet）

有序集合在数据较少时使用**压缩列表**实现。（有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节）

数据较多的时候使用**跳表**实现。

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。

**为什么这么实现？**

是为了在不同场景下**平衡****内存****占用和操作效率**：当元素数量少（默认 <128 个）且单个元素小时（默认 < 64 字节），用压缩列表可通过紧凑存储节省内存，此时数据量小，即使插入删除需移动内存，性能影响也可忽略；而当元素数量多或体积大时，压缩列表的遍历和内存移动成本会急剧上升，这时切换到跳表，利用其多级索引结构实现 O (logN) 的高效增删查和范围操作，避免性能瓶颈。

总结：

- String：**简单动态字符串**。
- List：**双向链表**、压缩列表。
- Hash：**哈希表**、压缩列表。
- Set：**整数集合**、哈希表。
- Sorted Set：**跳表**、压缩列表。

### 如何用redis实现消息队列？（list版本）

生产者端通过LPUSH将消息推入列表，消费者通过RPOP或者BRPOP从列表右侧取出消息，但是当RPOP从空列表读取时会读到nil，为了避免频繁空轮询，还是使用BRPOP比较好，阻塞式地弹出消息，会阻塞等待直到有消息可用。然后为了保证可靠性可以配合AOF持久化防止消息丢失，并在业务层实现简单的ACK机制——比如消费成功后再删除消息，失败则入队。

### 跳表是怎么实现的？

链表在查询数据的时候比较慢需要遍历整个列表，时间复杂度为O(n),于是就出现了跳表。跳表是在链表的基础上改进的，实现了一种多层的有序链表，这样的好处是能快速定位数据，时间复杂度是O(logN)。跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的zskiplistLevel结构体类型的level数组。level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如level[0] 就表示第一层，level[1] 就表示第二层。zskiplistLevel结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。

### 跳表是怎么设置层高的？

跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25（相当于概率25%），那么层数就增加1层，然后继续生成下一个随机数，直到随机数的结果大于0.25结束，最终确定该节点的层数。

## Redis为什么使用跳表而不是用B+树?

![img](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=YzMwNGNhNmRhNzQ1OGIzYTYzYjhjMGI0ZDVhMjViN2NfTXlhZThoU0NIckdDbm9ma2RhdzlPVDJxMkZsQ3hpNVRfVG9rZW46UWlMSGJkbnFob00wZ294bWdsV2NDbkRSbkRjXzE3Njk4NzI1MTY6MTc2OTg3NjExNl9WNA)

### Redis中的哈希表怎么扩容的？

进行refresh需要用到两个哈希表，分别为哈希表1和哈希表2.当触发refresh操作时，给哈希表2分配空间，通常是哈希表1的两倍，然后将哈希表1中的键值迁移到哈希表2，然后释放哈希表1的空间，把哈希表2设置为哈希表1。创建一个新的空哈希表，留给下一次refresh使用。

扩充怎么迁移的？

因为一次性迁移会对Redis造成阻塞，那么采用渐进式迁移方法，在rehash进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作之外，还会顺序将「哈希表1」中索引位置上的所有key-value迁移到「哈希表2」上；查找时如果在哈希表1上找不到就去哈希表2找，新增一般都是写入哈希表2。

### 压缩列表怎么实现的？

压缩列表是Redis为了节约内存而开发的，它是由**连续内存块组成的顺序型数据结构**，有点类似于数组。

### Redis是单进程还是多线程？

Redis 是单线程的，但是Redis 单线程指的是网络请求模块使用单线程进行处理，其他模块仍用多个线程，**Redis程序**并不是单线程的，在启动的时候，会启动后台线程。2.0版本会开启两个线程用于**处理关闭文件和**AOF刷盘**，4.0之后新增一个线程用于**异步释放Redis缓存。

# Redis持久化

#### RDB

把目前redis内存中数据生成一个快照（RDB文件），保存在硬盘中。如果发生事故，redis可以RDB文件进行文件读取，并将数据重新载入内存中。

RDB触发条件：

- 手动触发：
  - save：执行该指令后，主线程执行rdbSave函数，服务器进程阻塞，即不能处理任何其他请求
  - bgsave(background save)：本质上这个命令和save差不多，区别在于这个命令会fork了一个子进程，去执行rdbSave函数，因此主线程还是可以执行新请求的。
- 自动触发：配置文件中写入save m n，代表当m秒内发生n次变化时，会自动执行bgsave

优点：

- 适合大规模的数据恢复
- 节省磁盘空间
- 恢复速度快

缺点：

- 虽然Redis在fork时使用了写时拷贝技术，写时复制是建立在短时间内写请求不多的假设之下，如果写请求的量非常巨大，那么内存复制的压力自然也不会小。
- 数据安全性低：隔一段时间进行持久化的机制，如果发生故障容易导致数据丢失

#### AOF

将所有对Redis数据库进行修改命令记录到AOF文件。如果发生事故，redis可以通过AOF文件，将文件中的数据修改命令全部执行一遍，以此恢复数据

过程：

1. 客户端的请求写命令会被 append 追加到 **AOF 缓冲区**内
2. AOF 缓冲区根据 AOF 持久化策略（机制）（always,everysec,no）将操作 **sync 同步**到磁盘的 AOF 文件中
3. AOF 文件大小超过**重写策略**或手动重写时，会对AOF文件 **rewrite 重写**，压缩 AOF 文件容量（将流水账命令，整合为一条命令）
4. reids 服务重启时，会重新 load 加载 AOF 文件中的写操作，达到数据恢复的目的

优点：

- 备份机制更稳健，丢失数据概率更低
- 可读的日志文件，通过操作AOP文件，可以处理误操作

缺点：

- 占磁盘空间
- 恢复速度慢
- 每次读写都要同步，有一定的性能压力
- 出现bug造成不能恢复

#### AOF+RDB混合持久化方式（redis4.0）

在 AOF 文件的开头写入 RDB 格式的全量快照，后面追加增量的 AOF 命令。

### 如何选择合适的持久化方式

- 如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化。
- 如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB。
- 如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失。

# 过期键的删除策略、淘汰策略

### 过期删除策略有哪些？

### 定时删除



定时删除策略的做法是，**在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。** 定时删除策略的**优点**：

- **可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。**

定时删除策略的**缺点**：

- **在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。**

### 惰性删除



惰性删除策略的做法是，**不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。** 惰性删除策略的**优点**：

- **因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。**

惰性删除策略的**缺点**：

- **如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。**

### 定期删除

定期删除策略的做法是，**每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。** 定期删除策略的**优点**：

- **通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。**

定期删除策略的**缺点**：

- **内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。**
- **难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。**

### Redis过期键的删除策略

**redis内部用的是 惰性删除 和 定期删除** [![img](https://camo.githubusercontent.com/ccde62d5e2a60b4103c344bfe582d9779daec188f163cd3d5621bde995a01bd9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f776562702f32323231393438332f313732323532393230373034392d32313832666164642d663236662d346465372d616565362d3861373332313031386337612e7765627023617665726167654875653d25323366316631663126636c69656e7449643d7535396635346530652d323361372d342666726f6d3d70617374652669643d753030373037336331266f726967696e4865696768743d313630266f726967696e57696474683d31303830266f726967696e616c547970653d75726c26726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c7365267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7538303266633366312d656364342d343031632d623463352d3262376531613236656661267469746c653d)](https://camo.githubusercontent.com/ccde62d5e2a60b4103c344bfe582d9779daec188f163cd3d5621bde995a01bd9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f776562702f32323231393438332f313732323532393230373034392d32313832666164642d663236662d346465372d616565362d3861373332313031386337612e7765627023617665726167654875653d25323366316631663126636c69656e7449643d7535396635346530652d323361372d342666726f6d3d70617374652669643d753030373037336331266f726967696e4865696768743d313630266f726967696e57696474683d31303830266f726967696e616c547970653d75726c26726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c7365267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7538303266633366312d656364342d343031632d623463352d3262376531613236656661267469746c653d)

#### Redis 是怎么实现惰性删除的

Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：

- **如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 `\**lazyfree_lazy_expire\**` 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 给客服端；**
- **如果没有过期，不做任何处理，然后返回正常的键值对给客户端；**

#### Redis 是怎么实现定期删除的

再回忆一下，定期删除策略的做法：**每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。** *1、这个间隔检查的时间是多长呢？* 在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。 特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机抽取一定数量的 key 进行过期检查。 *2、随机抽查的数量是多少呢？* 我查了下源码，定期删除的实现在 expire.c 文件下的 `activeExpireCycle` 函数中，其中随机抽查的数量由 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 定义的，它是写死在代码中的，数值是 20。 也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。 接下来，详细说说 Redis 的定期删除的流程：

1. **从过期字典中随机抽取 20 个 key；**
2. **检查这 20 个 key 是否过期，并删除已过期的 key；**
3. **如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。**

可以看到，定期删除是一个循环的流程。 那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。

### 如何设置 Redis 最大运行内存？

在配置文件 redis.conf 中，可以通过参数 `maxmemory <bytes>` 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。 不同位数的操作系统，maxmemory 的默认值是不同的：

- **在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。**
- **在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。**

### 介绍一下Redis 内存淘汰策略》？

4.0之后增加了**lfu**

- ![img](https://camo.githubusercontent.com/642769e6e5620d0db493f33a389341b4103fd4282a7308eefe0ae7c1362f85fe/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032342f776562702f32323231393438332f313732323532393236303134322d37316531336534382d366139382d343763392d613034302d3533383161393837323664612e7765627023617665726167654875653d25323366366636663626636c69656e7449643d7535396635346530652d323361372d342666726f6d3d70617374652669643d753935363832613231266f726967696e4865696768743d333432266f726967696e57696474683d31303830266f726967696e616c547970653d75726c26726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c7365267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7538633338333331642d313737622d343962312d623936392d3131363930303261336264267469746c653d)

# 缓存异常

### 如何保证缓存与数据库双写时的数据一致性？（重要）

核心思想：当缓存的数据有更新值了，它采用的不是更新缓存数据，而是删除缓存数据。

**不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。**

https://zhuanlan.zhihu.com/p/490779391

1. **Cache Aside 策略**（旁路缓存策略，更新数据库+删除缓存）

   - 写策略：**先更新数据库，再删除缓存**
   - 读策略：如果读取的数据命中了缓存，则直接返回数据；如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

   缺点：每次更新数据都会删除缓存，降低了缓存命中率。

   Q：为什么**先更新数据库，再删除缓存**，而不是先删除缓存，后更新数据库？

   A：1. 先删除缓存，后更新数据库存在的问题

   [![在这里插入图片描述](https://camo.githubusercontent.com/06c2d666ad50699f0e21351617e00e15efe84f61a9fb8b94fde03d244873be7b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313031313230333833373734302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a41774d6a63304e773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)](https://camo.githubusercontent.com/06c2d666ad50699f0e21351617e00e15efe84f61a9fb8b94fde03d244873be7b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313031313230333833373734302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a41774d6a63304e773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)

   1. **先更新数据库，再删除缓存**也会存在问题，不过这种问题出现的几率并不高。

      [![在这里插入图片描述](https://camo.githubusercontent.com/8f519c9b6039a822f05cadfdb5eaffdc36b4deba120c79b9997883785e79145c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313031313230343134343833372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a41774d6a63304e773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)](https://camo.githubusercontent.com/8f519c9b6039a822f05cadfdb5eaffdc36b4deba120c79b9997883785e79145c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313031313230343134343833372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a41774d6a63304e773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)

      原因：缓存的写入通常远远快于数据库的写入，所以在实际中很难出现请求 B 已经更新了数据库并且清空了缓存，请求 A 才更新完缓存的情况。而一旦请求 A 早于请求 B 清空缓存之前更新了缓存，那么接下来的请求就会因为缓存为空而从数据库中重新加载数据，所以不会出现这种不一致的情况。

   [![在这里插入图片描述](https://camo.githubusercontent.com/1c240d4da11c2435903fc582a9e01384b101fa80e34b17873fee99f082a395d7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313031313230343631393930392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a41774d6a63304e773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)](https://camo.githubusercontent.com/1c240d4da11c2435903fc582a9e01384b101fa80e34b17873fee99f082a395d7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313031313230343631393930392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a41774d6a63304e773d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572)

2. 更新数据库+更新缓存（两种方案）

- 更新缓存前先加个==分布式锁==，保证同一时间只有一个请求在更新缓存，但加锁对写入的性能会带来影响
- 更新完毕后给缓存加一个较短的==过期时间==，这样即使出现缓存不一致的情况，缓存的数据也会很快过期

适合**业务对缓存命中率有很高**的要求，因为更新缓存并不会出现缓存未命中的情况。

1. 延迟双删（删除缓存+更新数据库）

   1. 先删缓存，在更新数据库
   2. 睡眠一段时间，再删一遍缓存

   加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。

[![image-20230314154641085](https://camo.githubusercontent.com/ecef8bc1b64702c80d2b27947232aa0f16414dcb787f9a875a0a88101e665dfd/68747470733a2f2f67697465652e636f6d2f5472616e736d6967726174696f6e5f7a686f752f7069632f7261772f6d61737465722f696d6167652d32303233303331343135343634313038352e706e67)](https://camo.githubusercontent.com/ecef8bc1b64702c80d2b27947232aa0f16414dcb787f9a875a0a88101e665dfd/68747470733a2f2f67697465652e636f6d2f5472616e736d6967726174696f6e5f7a686f752f7069632f7261772f6d61737465722f696d6167652d32303233303331343135343634313038352e706e67)

#### Cache Aside 什么情况会导致缓存和数据库不一致？



更新数据库成功，但删除缓存失败。

如果删除缓存失败，命中缓存后就会一直返回错误数据。

解决方案

- 重试机制

  引入消息队列，将删除缓存操作加入队列，由消费者来操作数据（异步执行缓存操作）

  - 如果**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
  - 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。

- 订阅 MySQL binlog，再操作缓存

  类似阿里开源的 Canal 中间件模拟 MySQL 主从复制，把自己伪装成 MySQL 的从节点，向主节点发送 dump请求，MySQL 收到请求后，就将更新的 binlog 给 Canal。Canal 再将 binlog 解析转换为==便于读取==的结构化数据，给下游程序订阅使用。

### 什么是缓存击穿？

定义：查询**某个**数据的值，该值在缓存中不存在，在数据库中存在

问题：如果对该值的查询**请求量特别大**，这些请求发现缓存中没有该数据（通常是**缓存过期**），一般都会去数据库**请求数据**，导致数据库宕机。

解决方案：

- 从Redis角度
  - 设置热点数据永不过期
  - 热点数据后台启动一个异步线程，重新把数据回填给缓存
- 从Mysql角度
  - 通过加锁的方式，减少击穿后的直接流量
    - 当**缓存失效**时，**不是立即**去load db
    - 先使用**redis**某些**带成功值得操作**，如**setnx**去设置一个**mutex key**
    - 当操作返回**成功**，再去**load db**，并**回设缓存**，并**删除mutex key**
    - 若操作**失败**，说明**有线程在load db**，当前线程可**sleep一段时间再次查询**

1. 使用 setnx（分布式锁）设置互斥锁，保证同一时间只有一个业务线程请求缓存。
2. 不给热点数据设置过期时间。

### 什么是缓存穿透？

定义：查询一个数据库也不存在的数据，即缓存查不到，数据库也查不到，导致缓存和数据库都被打穿

解决方案：

1. 拦截非法查询请求

2. 缓存空对象：出现缓存穿透时，针对查询的数据设置空值或默认值，这样就能命中缓存了

3. 布隆过滤器：在写入数据库时用布隆过滤器做个标记，当缓存失效需要查数据库时，可以快速判断数据是否存在

   设计k个hash映射函数，把数据库中的有效数据通过hash函数得到对应的位置，在bitmap上置为1。

   查询数据通过这一系列hash函数，判断对应位置是否全为1。如果存在一位是0，这个数据一定不在数据库中；如果全为1，大概率在数据库中。

![image.png](https://camo.githubusercontent.com/f904d750a4a7703e1a1378726ad0d451044b6916f1a0efe9a3d48b63b8b4d4b6/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f32313632363037332f313632383932313637393338342d64326530393165382d376430662d343830362d613339372d6563313366646337366532332e706e67)

**如何选择：**针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第二种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第三种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第二种方式进行缓存。

### 什么是缓存雪崩？

定义：一大批被缓存的数据同时失效，此时对于这一批的数据请求全打到数据库上，导致数据库宕机。

缓存雪崩与缓存击穿的区别就是缓存雪崩对很多key缓存（多点）而言，缓存击穿是对某一个key（单点）而言。

解决方案：

- 事前：

  - 分析失效时间，尽量让失效时间分散

  - 缓存预热，在上线前将热数据直接加载到缓存系统

  - 构建多级缓存，redis+其他缓存

- 事中：
  - 通过加锁的方式，减少并发量

- 事后：
  - 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。

### 什么是缓存预热？

缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。 如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。 缓存预热解决方案：

- 数据量不大的时候，工程启动的时候进行加载缓存动作；
- 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；
- 数据量太大的时候，优先保证热点数据进行提前加载到缓存。

### 什么是缓存降级？

缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。 在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

- 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
- 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
- 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
- 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

### Redis是单进程还是多线程？

Redis 是单线程的，但是Redis 单线程指的是网络请求模块使用单线程进行处理，其他模块仍用多个线程，**Redis程序**并不是单线程的，在启动的时候，会启动后台线程。2.0版本会开启两个线程用于**处理关闭文件和****AOF****刷盘**，4.0之后新增一个线程用于**异步释放Redis缓存。**



# 事务

### 如何实现redis原子性？

redis 执行一条命令的时候是具备原子性的，因为redis 执行命令的时候是单线程来处理的，不存在多线程安全的问题。

如果要保证 2 条命令的原子性的话，可以考虑用lua 脚本，将多个操作写到一个Lua 脚本中，Redis 会把整个Lua脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了Lua脚本中操作的原子性。

比如说，在用redis 实现分布式锁的场景下，解锁期间涉及 2个操作，分别是先判断锁是不是自己的，是自己的才能删除锁，为了保证这 2个操作的原子性，会通过lua 脚本来保证原子性。

### 除了lua有没有什么也能保证redis的原子性？

redis事务，如果redis事务正常执行，没有发送任何错误，那么可以使用muti和exec配合使用，就可以保证多个操作完成。但是，如果事务执行发生错误了，就没办法保证原子性了。比如说2个操作，第一个操作执行成果了，但是第二个操作执行的时候，命令出错了，那事务并不会回滚，因为Redis 中并没有提供回滚机制。



# 集群

### Redis主从复制

**完全同步**

完全同步出现在**第一次连接**、**从服务数据丢失**时。

- 从服务器发送psync命令，请求同步
- 主服务器收到请求后进行BGSAVE命令生成RDB快照并发送给从服务器，
- 从服务器接收RDB文件，并会清空当前的数据集，并载入RDB文件中的数据。
- 在这期间，主服务器会记录所有接收到的写命令到缓冲区，等RDB文件传输完成后，主服务器会将缓冲区的命令发给从服务器，从服务器会执行这些命令以保证数据的一致性。

**增量同步**

- 当slave断开重连后，会发送psync 命令给master。
- master首先会对服务器运行id进行判断，如果与自己相同就进行判断偏移量
- master会判断自己的偏移量与slave的偏移量是否一致。
- 如果不一致，master会去缓冲区中判断slave的偏移量之后的数据是否存在。
- 如果存在就会返回+continue回复，表示slave可以执行部分同步了。
- master发送断线后的写命令给slave
- slave执行写命令。

### 主服务器怎么知道要将哪些增量数据发送给从服务器呢？

主服务器和从服务器在写和读都有一个各自的偏移量，网络断开后，当从服务器重新连上主服务器时，从服务会通过psync命令将自己的复制偏移量发送给主服务器，主服务器根据自己的偏移量和从服务器发送过来的偏移量之间的差距，然后来决定对从服务器执行哪种同步操作。如果判断出从服务器要读取的数据还repl_backlog_buffer 缓冲区里，那么主服务器将采用增量同步的方式;相反，如果判断出从服务器要读取的数据已经不存在缓冲区里，那么主服务器将采用全量同步的方式。

### 由于主从延迟导致读取到过期数据怎么处理？

1. 通过scan命令扫库：当Redis中的key被scan的时候，相当于访问了该key，同样也会做过期检测，充分发挥Redis惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。
2. Redis加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了key是否过期以及对主从库的判断，如果key已过期，当前访问的master则返回null；当前访问的是从库，且执行的是只读命令也返回null。

### Redis主从架构数据会丢失吗，为什么？

有两种数据丢失的情况：

1. 异步复制导致的数据丢失：因为master -> slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。
2. 脑裂导致的数据丢失：某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据。

### Redis哨兵模式

哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。能够后台监控主机是否故障，如果主库出现故障了，哨兵进行投票，根据投票数自动将从库升级成主库。

本质上，哨兵是一个不提供数据服务的redis服务器。

[![image.png](https://camo.githubusercontent.com/7039ad822e2342d2b7861418ffc70b4aa962da1a1a3ea4de55be0564762851f1/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f32313632363037332f313632393031323038363537382d64353731383363362d633134322d343666652d623735312d6236396161623835303366352e706e67)](https://camo.githubusercontent.com/7039ad822e2342d2b7861418ffc70b4aa962da1a1a3ea4de55be0564762851f1/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f32313632363037332f313632393031323038363537382d64353731383363362d633134322d343666652d623735312d6236396161623835303366352e706e67)

优点：

- 基于主从复制
- 主从可以自动切换，系统更健壮，可用性更高

缺点：

- 较难支持在线扩容

### **哨兵原理**

**判断节点是否存活**

每个哨兵定期向 Redis 服务器发送 PING 命令，以检测服务器是否处于活跃状态。如果哨兵连续一定次数未收到服务器的响应，就认为服务器主观下线。然后哨兵会从从节点中选择一个作为主节点。

**选出新主节点**

在发现主服务器下线后，哨兵会协调选举一个新的主服务器。这个过程中，哨兵会考虑每个可用的从服务器，选择一个作为新的主服务器，并将其他从服务器配置为复制新的主服务器。

具体过程：

- 选择候选从服务器： 哨兵会从可用的从服务器中选择一组候选服务器，通常选择**复制偏移量（replication offset）最大**的从服务器。
- 计算投票： 每个哨兵为每个候选从服务器投票。投票的考量因素包括**从服务器的复制偏移量、连接质量、优先级**等。
- 达成共识： 哨兵们根据投票结果达成共识，选择一个从服务器作为新的主服务器。这通常需要获得多数哨兵的同意。

**更新配置信息**

一旦新的主服务器被选出，哨兵会**更新 Redis 集群的配置信息**，包括将新的主服务器的**地址和****端口**通知给其他哨兵和客户端。

**通知客户端**

哨兵会向客户端发送通知，告知客户端新的主服务器的位置，以便客户端能够重新连接。

### redis集群模式

#### 原理

Redis 集群模式通过将数据分片存储在多个节点上，来实现数据的水平扩展和高可用性。每个节点负责处理部分数据，并且可以自动处理节点的增加、删除和故障恢复。

#### 数据分片

Redis 集群采用哈希槽（hash slot）机制进行数据分片。整个数据集被划分成 16384 个哈希槽（hash slots），每个键通过哈希函数（CRC16）计算得到一个哈希值，然后对 16384 取模，确定键所在的哈希槽。每个节点负责一定范围的哈希槽。

#### 数据分片的具体步骤

1. **哈希计算**：对键名进行 CRC16 哈希计算，得到一个哈希值。
2. **槽分配**：将哈希值对 16384 取模，得到键所在的哈希槽编号。
3. **槽映射到节点**：根据槽编号查找对应的节点，将数据存储在该节点上。

#### 故障恢复和高可用性

1. **主从复制**：每个主节点（master）都有一个或多个从节点（slave）进行数据复制。主节点故障时，从节点可以自动提升为主节点，继续提供服务。
2. **哨兵机制（Sentinel）**：监控集群节点的状态，自动进行主从切换和故障恢复，确保高可用性。

### 具体示例

假设有三个节点的Redis集群：

- 节点A负责哈希槽0-5460
- 节点B负责哈希槽5461-10922
- 节点C负责哈希槽10923-16383

当键“key1”要存储时：

1. 计算哈希值：CRC16("key1") = 63494。
2. 取模计算哈希槽：63494 % 16384 = 5494。
3. 查找哈希槽5494所在节点：该槽属于节点B。
4. 将“key1”存储在节点B上。

### 总结

Redis集群通过哈希槽机制进行数据分片，每个键通过哈希计算确定存储位置，实现数据的分布式存储。通过主从复制和哨兵机制，保证了集群的高可用性和故障恢复能力。

# 分布式问题

### Redis分布式锁的实现原理？

分布式锁是用于分布式环境下并发控制的一种机制，用于**控制某个资源在同一时刻只能被一个应用所使用**。Redis分布式锁的的核心实现主要是set lock_key unique_value NX PX 命令的原子性来实现加锁的，key则是数据的主键，value是客户端生成的唯一标识，用来区分不同客户端的锁操作，而NX就是在key不存在才插入，才对key进行设置操作。PX是用来设置锁的过期时间，以防止客户端无法释放锁。解锁就是删除lock_key,那么在解锁的时候就要保证判断锁的唯一标识是否为**加锁客户端**，**是的话才删除**，正因为解锁是两个操作，这时就要使用**Lua脚本**来保证解锁的原子性。

### 实现分布式锁有哪些方案？

**1、基于关系型数据库，**如MySQL基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等

缺点：

- 没有锁失效时间，一旦失败会导致锁记录一直在数据库中，其他线程无法再获得到锁。

- 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
- 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

**2、基于Redis实现** 

优点：

-  Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。 

缺点：

- Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮；
- key 的过期时间设置多少不明确，只能根据实际情况调整；
- 需要自己不断去尝试获取锁，比较消耗性能。

**3、基于zookeeper** 

优点：

-  zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。 

缺点： 

- 在高请求高并发下，系统疯狂的加锁释放锁，最后 zk 承受不住这么大的压力可能会存在宕机的风险。

**超时解锁导致并发 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。 A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：**

- 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
- 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

**如果锁已经过期了，但线程任务还没有执行完怎么办？**

1. Redisson实现的看门狗方案：每1/3锁时间检查一次，若线程还持有锁，则刷新过期时间；
2. 超时回滚：当解锁时发现锁已经被其他线程获取了，说明我们此时执行的操作不安全，需要回滚，并返回失败。

### redis集群环境下分布式锁

为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 RedLock（红锁）。

- Redlock 算法的基本思路，

  是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败

  - 获取当前Unix时间，毫秒单位
  - 使用相同的key依次尝试从N个实例获取锁
  - 客户端使用当前时间减去开始获取锁的时间，只有当半数以上的节点都获取到锁且锁的使用时间小于锁失效时间时，锁才算获取成功
  - 获取到锁以后，key的真正有效时间 = 有效时间 - 获取锁的时间
  - 若获取锁失败，客户端在所有的redis实例上进行解锁



# 场景

### 大key问题

redis大key问题指的是某个key对应的value值所占的内存空间比较大，导致Redis的性能下降、内存不足、数据不均衡以及主从同步延迟等问题。

解决方法：

- 对大key进行拆分
- 对过期数据进行定期清。堆积大量过期数据会造成大Key的产生。
- 使用合适的数据结构

### redis 删除一个 大key，该怎么操作

### 删除大key的方法

1. 分批删除
   - 将大key的数据分批删除，避免一次性操作导致阻塞。
   - 使用 `SCAN` 命令迭代获取大key中的元素，再逐个删除。
2. 异步删除
   - 使用 Redis 4.0 引入的 `UNLINK` 命令，类似于 `DEL`，但实际删除操作在后台线程中进行，减少阻塞。
3. 设置过期时间
   - 为大key设置过期时间，让 Redis 自动在后台删除该键。
4. 使用 Lua 脚本
   - 编写 Lua 脚本在 Redis 服务器端分批删除大key中的数据，以减少阻塞。

### 热点key问题

访问频率很高的key就被称为热key，由于访问量大可能会导致**Redis服务器因资源不足而产生宕机**的情况。

解决方法：

- 负载均衡：设置多个从节点负责读操作，并且将请求分发到不同的节点减轻单个节点的压力；
- 设计二级缓存，先获取**本地缓存**中的数据，获取不到再访问Redis获取；
- 数据分片：将数据存储到不同的节点上，避免单个节点存储多个热key导致资源不足。

### 一致性hash了解过吗？

当然，了解一致性哈希。它是一种分布式系统中常用的哈希算法，用于解决数据分布问题。

#### 一致性哈希的基本概念

1. **目标**: 一致性哈希的主要目的是将数据均匀分布到多个节点上，并在节点增减时尽可能减少数据的重新分配。
2. **哈希环**: 一致性哈希使用一个逻辑上的环来分布数据。每个节点和数据项都被映射到环上的一个位置。
3. 映射
   - **节点映射**: 每个节点通过哈希函数映射到环上的某个位置。
   - **数据映射**: 数据也通过哈希函数映射到环上的位置。
4. **数据存储**: 数据存储在顺时针方向上第一个经过的节点上。例如，如果数据的哈希值位于节点A和节点B之间，那么数据将被存储在节点A上。
5. 节点变动
   - **增加节点**: 当增加一个节点时，它只会影响到环上它之前存储数据的节点。新的节点只会接管部分数据，减少了数据迁移。
   - **删除节点**: 当删除一个节点时，它的数据将转移到环上顺时针方向的下一个节点。

### 优点和缺点

**优点**:

- **平衡负载**: 节点增加或减少时，对数据的影响最小。
- **减少数据迁移**: 节点变化时，只需迁移少量数据。

**缺点**:

- **数据分布不均**: 如果节点数量变化较大或哈希函数不均匀，数据分布可能不均。
- **计算复杂性**: 哈希环上的节点查找和数据分布需要一些额外的计算和维护。

在实际应用中，一致性哈希常用于负载均衡、缓存系统和分布式存储系统中。

### 用redis实现百万用户游戏积分排行榜

Redis是一个高性能的内存数据存储系统，对于游戏的积分排行榜来说非常适合。可以通过以下步骤来实现百万用户游戏积分排行榜：

1. 使用Redis的Sorted Set数据结构存储用户积分：将用户ID作为成员，积分作为分数，每当用户得分变化时，通过ZADD命令更新积分。
2. 使用ZREVRANGE命令获取排行榜：该命令可以根据分数的降序返回成员，从而实现排行榜。
3. 使用Hash数据结构存储用户详细信息：将用户ID作为键，用户详细信息（例如用户名、头像等）作为值，可以通过HGET命令快速获取用户详细信息。

这样，通过排序集合和哈希数据结构的结合，就可以实现高效、稳定的百万用户游戏积分排行榜。
