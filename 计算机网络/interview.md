### 讲一下计算机网络的各层协议及作用？

**OSI模型**

应用层，负责给应用程序提供统一的接口;

表示层，负责把数据转换成兼容另一个系统能识别的格式;

会话层，负责建立、管理和终止表示层实体之间的通信会话;

传输层，负责端到端的数据传输;

网络层，负责数据的路由、转发、分片;

数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址;

物理层，负责在物理网络中传输数据帧;

**tcp**模型：  **应用层** **传输层** **网络层** **网络接口层**

应用层 支持 HTTP、SMTP 等最终用户进程

传输层 处理主机到主机的通信（TCP、UDP)

网络层 寻址和路由数据包 (IP 协议)

网络接口层 通过物理介质移动比特

### 数据网络传输过程

https://www.cnblogs.com/guoxiaoyu/p/17690242.html

![应用层](https://camo.githubusercontent.com/5c54994c5ac920784584ad5c95f734e51ae6774852e5dd60e41b314df736bd42/68747470733a2f2f7777772e746f70676f65722e636f6d2f7374617469632f362e312f322e706e67)

### ARQ协议

自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中**数据链路层**的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。

### TCP 三次握手建立连接

![img](https://my.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAzODY2MGEwNmY5MDYzZmY4NTdlOWU1ZTEyZjBhZTVfdUZNVFpjdEtoTVdyYlRuMmpCRTNsUmY4WENQZ21iaHBfVG9rZW46Q1F4ZGJsZWR1b256Rlh4S3hFVmNTTVBMbnFoXzE3NzAxMjYyNjY6MTc3MDEyOTg2Nl9WNA)

三次握手机制：

- 第一次握手：客户端请求建立连接，向服务端发送一个**同步报文**（SYN=1），同时选择一个随机数 seq = x 作为**初始序列号**，并进入SYN_SENT状态，等待服务器确认。
- 第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送**同步确认报文**（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为初始序列号，此时服务器进入SYN_RECV状态。
- 第三次握手：客户端收到服务端的确认后，向服务端发送一个**确认报文**（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。

理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

总结（A：客户端 B：服务端）：

- 首先 B 处于 LISTEN（监听）状态，等待 A 的连接请求。
- A 向 B 发送连接请求报文，SYN=1，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
- B 收到 A 的确认后，连接建立。

##### 半连接队列

服务器第一次收到客户端的SYN之后，就会处于 **SYN_RCVD**（同步已接收）状态，此时双方还没有完全建立连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称为半连接队列。

##### 全连接队列

当已经完成三次握手，建立起的连接后，应用没有取走的请求会组成一个队列，这个队列就是全连接队列，如果队列满了可能就会出现请求丢失。

### **为什么需要三次握手，而不是两次？**

主要有三个原因：

1. 防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。
   1.  在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。

   2.  客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。

   3.  此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。
2. 三次握手才能让双方均确认自己和对方的发送和接收能力都正常。
   1.  第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；

   2.  第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；

   3.  第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；

   4.  可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。
3. 告知对方自己的初始序号值，并确认收到对方的初始序号值。

TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。

#### 什么是 SYN洪泛攻击？如何防范？

SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。

原理：

- 在三次握手过程中，服务器发送 `[SYN/ACK]` 包（第二个包）之后、收到客户端的 `[ACK]` 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 `SYN_RECV`（等待客户端响应）状态。如果接收到客户端的 `[ACK]`，则 TCP 连接成功，如果未接受到，则会**不断重发请求**直至成功。
- SYN 攻击的攻击者在短时间内**伪造大量不存在的 IP 地址**，向服务器不断地发送 `[SYN]` 包，服务器回复 `[SYN/ACK]` 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。
- 这些伪造的 `[SYN]` 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。

检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。

防范：

- 通过防火墙、路由器等过滤网关防护。
- 通过加固 TCP/IP 协议栈防范，如增加最大半连接数，缩短超时时间。
- SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。

### 三次握手最后一次握手的包丢失了会发生什么？

客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISHED 状态。 如果第三次握手丢失：

1. 触发超时重传，服务端重发第二次握手报文（SYN-ACK），直到收到第三次握手；
2. 如果第三次握手一直丢失，第二次握手最大重传次数由 tcp_synack_retries=2 参数控制。当服务端已达到最大重传次数后，会再等待一段时间（上一次超时时间的2倍：RTO*2），之后服务端会断开连接。

### TCP四次挥手连接

0）初始状态：刚开始双方都处于 `ESTABLISHED`状态。假如是客户端先发起关闭请求。

1）第一次挥手：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并**停止再发送数据，主动关闭 TCP 连接**。此时客户端处于 `FIN_WAIT1` 状态，等待服务端的确认。

> FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；

2）第二次挥手：服务器收到FIN报文后知道客户端想断开连接，但此时服务器不一定能做好准备，可能还有未传输完的消息，所以服务器只能先返回一个ACK报文段，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，并进入 `CLOSE_WAIT` 状态；

> CLOSE-WAIT - 等待从本地用户发来的连接中断请求；

**此时的 TCP 处于半关闭状态，客户端到服务端的连接释放**。客户端收到服务端的确认后，进入 `FIN_WAIT2`（终止等待 2）状态，等待服务端发出的连接释放报文段。

> FIN-WAIT-2 - 从远程TCP等待连接中断请求；

3）第三次挥手：服务器已经准备好断开连接，向客户端发送FIN报文段，且指定一个序列号，关闭服务器到客户端的数据传输，服务器进入 `LAST_ACK`状态，等待客户端的确认。

> LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；

4）第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），然后客户端进入 **`TIME_WAIT` （时间等待）状态**并==等待2MSL时间后进入 `CLOSED`状态==，服务器收到客户端的FIN报文段后会进入 `CLOSED`状态，完成四次挥手。

> TIME-WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；

### TCP为什么要四次挥手?

由于 TCP 的**半关闭**（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。

==四次挥手是确保数据都发送完了才结束。==

### TIME_WAIT

> MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做主要有两个原因：

1. 遇到数据包的丢失还可以重传，确保最后一个确认报文能够到达。（主要保证TCP协议的全双工连接能够可靠关闭）
2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。（保证这次连接的重复数据段从网络中消失）

### 服务器出现大量TIME_WAIT状态的原因有哪些？

TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接，有3种场景：

1. HTTP没有使用长连接：从HTTP/1.1开始是默认开启长连接的。当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。
2. HTTP长连接超时：为了避免资源浪费（客户端完成一个HTTP请求后就不再发起新的请求），一般web服务软件会提供一个长连接超时参数，超过该时间后客户端还是没有发起新的请求，则服务端主动关闭连接。
3. HTTP长连接的请求数量达到上限：QPS较高，而长连接数量上限设置较低时触发。

### TIME_WAIT过多造成的危害及处理方式

危害：

1. 占用端口资源，一个 TCP 连接至少消耗**发起连接方**的一个本地端口。

   对于==客户端==（发起连接方）来说，端口资源是有限的（16bit，2^18^个端口），被占满就会导致无法创建新的连接。

2. 占用内存资源

   理论上服务端可以建立很多连接，因为服务端只监听一个端口，不会因为 TCP 连接过多而导致端口资源受限。但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。

处理方式：

1. 增加TCP端口范围
2. 升级服务器硬件或者增加更多的服务器来分担负载
3. 减少连接的持续时间
4. 调整TCP参数，如TIME_WAIT超时时间、最大连接数等
5. 使用连接重用，在不同的TCP连接之间共享连接资源

主动断开连接会进入 TIME_WAIT 状态。**如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT。**

### TCP 怎么保证可靠传输

==可靠传输就是保证接收方收到的字节流和发送方发出的字节流是完全一样的。==

TCP的可靠传输我认为是从「事前预防」和「事后补救」两个维度来搭建的

- **数据校验——事前预防**：TCP报文头有校验和，用于校验报文是否损坏。
- **确认应答机制——事前预防**：接收方收到 TCP 报文段后就会返回一个确认应答消息。
- **流量控制——事前预防**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- **拥塞控制——事后补救**：当网络拥塞出现丢包时，通过拥塞窗口，减少数据的发送，防止包丢失。
- **重传机制——事后补救**：发送方发送一段时间后没有收到确认就会重传。

### TCP拥塞控制

慢启动、拥塞避免、快重传、快恢复

慢启动：所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探网络的承受能力，也就是说由小到大逐渐增加拥塞窗口的大小，以免直接扰乱了网络通道的秩序。初始化拥塞窗口（cwnd）的大小为1，每过一个RTT时间，拥塞窗口值翻倍（即每收到一个ACK，窗口大小增加1）。+

拥塞避免：当拥塞窗口达到慢启动阈值（ssthresh）时，窗口大小不再呈指数上升，窗口每轮次加一，呈线性增长，避免增长过快导致网络拥塞。拥塞避免算法可以避免窗口增长过快导致网络拥塞，缓慢地增加调整到网络的最佳值；

快重传：当收到对一个报文的三个重复的 ACK 时，认为丢了一个中间包，进入快重传阶段，要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。

快恢复：当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。每接收一个重复ACK，拥塞窗口的值暂时增加1，当接收到一个好的ACK，表明报文段重传成功，退出快速恢复阶段，将拥塞窗口大小设置为慢启动门限值。

[![img](https://camo.githubusercontent.com/8af0485074a287c742365ab9b42241d346c3d11ec578633214b901bb3a48857d/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d34346235363134363764666661323834316161333033616437313438616635615f622e6a7067)](https://camo.githubusercontent.com/8af0485074a287c742365ab9b42241d346c3d11ec578633214b901bb3a48857d/68747470733a2f2f706963332e7a68696d672e636f6d2f76322d34346235363134363764666661323834316161333033616437313438616635615f622e6a7067)

#### 快重传和超时重传的区别

- 发生时机不同
  - 超时重传发生的时机是：如果某一个报文段的重传定时器超时后，该报文段依然没被确认，则重传该报文段。引起的原因是报文确认超时 ( 阻塞或者丢失 )
  - 快重传发生的时机是：接收方发送三个重复的 ACK 给发送方，发送方立即进行重传。引起的原因是接收方收到的报文无序 ( 比如报文发生丢失 )

### TCP粘包/拆包

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。

### 原因

主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。

“粘包”可发生在发送端也可发生在接收端：

- 由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。
- 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。

### 解决办法

出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。

封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。

#### 为什么UDP没有粘包/拆包？

- TCP协议是面向字节流的协议，UDP是面向报文的协议
  - UDP每一段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据
- UDP具有保护消息边界

## TCP 和 UDP 的区别

| **UDP**                            | **TCP**                                  |
| ---------------------------------- | ---------------------------------------- |
| UDP无连接                          | TCP面向连接，全双工通信                  |
| 尽最大努力交付                     | 提供可靠的服务（不错、不丢、不重、有序） |
| 面向报文                           | 面向字节流                               |
| 没有拥塞控制                       | 有拥塞控制                               |
| 支持一对一，一对多，多对一和多对多 | 点到点                                   |
| 首部开销小                         | 首部开销大                               |

## 在浏览器中输入url地址后显示主页的过程

- 根据域名，进行DNS域名解析
- 拿到解析的IP地址，建立TCP连接
- 向IP地址发送HTTP请求
- 服务器响应HTTP请求并返回HTTP报文
- 关闭TCP连接
- 浏览器解析HTML渲染页面

### DNS域名解析的工作流程？

DNS分为迭代查询和递归查询

对于迭代查询，需要查询域名的ip地址时，会先去本地服务器查，本地服务器有就直接返回，没有就去查根DNS服务器，根DNS服务器会告诉本地DNS服务器该去查询那个顶级服务器，接下来本地服务器向该顶级DNS服务器发送查询请求，顶级DNS服务器收到请求后会告诉本地DNS服务器去查询哪个权限DNS服务器。最后本地DNS服务器查询权限服务器获得该域名的iP地址。缓存下来并发送给主机，主机也缓存在本地。

递归查询是本地DNS服务器依次去询问根DNS服务器、顶级DNS服务器和权限DNS服务器。

### DNS的底层使用TCP还是UDP？

DNS基于UDP协议实现，DNS使用UDP协议进行**域名解析****和数据传输。**因为基于UDP实现DNS能够提供**低延迟****、简单快速、轻量级**的特性。符合DNS这种需要**快速响应**的域名解析服务。

### session、cookie和token

cookie 是**服务器发送到客户端并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。

Session是服务器保存的一段数据，用于存储客户端的状态信息。当客户端第一次访问服务器时，服务器会创建一个唯一的session ID，并将其返回给客户端。客户端每次请求时，都会携带该session ID，服务器根据该ID来查找对应的session数据，并进行相应的处理。

抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。

Token 其实就是一串字符串而已，只不过它是被加密后的字符串，它通常使用 uid (用户唯一标识)、时间戳、签名以及一些其它参数加密而成，以作客户端进行请求的一个令牌。当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

**session 是空间换时间，token 是时间换空间。**

> Session是一种服务端存储用户状态信息的机制，通过在服务端保存用户相关数据来实现跨请求的数据共享。因为需要在服务端存储数据，所以会占用一定的存储空间。当用户数量较大时，会给服务器带来很大的压力，因此使用Session需要考虑空间成本。因此可以说Session是通过空间换时间来实现的，即用存储空间换取了更高效的用户状态管理和访问。
>
> Token则是一种基于令牌(Token)的认证机制，主要用于客户端与服务端之间的身份验证和授权。将用户身份信息加密后生成一个Token，发放给客户端，客户端在后续请求中带上该Token进行身份验证。相比Session，Token不需要在服务端保存用户状态信息，而是将其加密后交给客户端保管，使得服务端无需占用过多的存储空间。因此可以说Token是通过时间换空间来实现的，即用计算时间换取了更小的存储空间和更高效的认证和授权。

他们的目的都是一样的：**鉴权和认证。**

### Cookie和Session的区别

1、存储的位置不同。Cookie 在客户端（浏览器），Session 在服务器端。

2、存储的数据类型不同。Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。

3、安全性不同。Session 比 Cookie 安全。

4、存储大小不同。Cookie大小受浏览器的限制，一般单个Cookie保存的数据不能超过4K。Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

5、有效期不同。 Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

### URI、URL

URI：统一资源标识符，用来==唯一==的标识一个资源。

URL：统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

## HTTP、HTTPS

### HTTP

Http协议是由Http请求和响应组成，是一个简单的请求-响应协议，基于TCP协议。当在浏览器中输入网址访问某个网站时，浏览器会将你的请求封装乘一个Http请求发送给服务器，服务器接收到请求后会组织响应数据封装成一个Http响应返回给浏览器。

HTTP是一种无状态协议，这意味着服务器不会保存任何与客户端相关的信息，这种无状态的特点使得HTTP协议不能很好地处理跨请求的数据共享问题。为了弥补无状态的不足，常用的方法是使用Cookie和Session。

#### Http请求报文与响应报文格式

[![img](https://camo.githubusercontent.com/efc8d22b9dad064a12dc0b8d3b19452cb90ae42da8fb8e722cf74bf8411f1439/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313036363730372f3230313930372f313036363730372d32303139303732333230353933393731382d323035303530333034392e706e67)](https://camo.githubusercontent.com/efc8d22b9dad064a12dc0b8d3b19452cb90ae42da8fb8e722cf74bf8411f1439/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313036363730372f3230313930372f313036363730372d32303139303732333230353933393731382d323035303530333034392e706e67)

请求行、请求头、请求体、空行

[![img](https://camo.githubusercontent.com/cb7fd66eb50d63c0e27b6181f836a18a14b1357cc2a0ca7f1a976dc50497cea7/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313036363730372f3230313930372f313036363730372d32303139303732333231303533323032362d3630303838373630342e706e67)](https://camo.githubusercontent.com/cb7fd66eb50d63c0e27b6181f836a18a14b1357cc2a0ca7f1a976dc50497cea7/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f313036363730372f3230313930372f313036363730372d32303139303732333231303533323032362d3630303838373630342e706e67)

状态行、响应头、响应体、空行

##### Http首部

https://blog.csdn.net/weixin_39649965/article/details/110707143

**1、通用首部：**请求报文和响应报文都支持，换句话说，就是既可以出现在请求报文中，也可以出现在响应报文中。

**2、请求首部（请求头）：**出现在请求报文第一行(请求行)的后面，为请求报文添加一些附加信息

- Accept：浏览器可接受的MIME类型。
- Accept-Charset：浏览器可接受的字符集。
- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。
- Accept-Language：浏览器支持的语言。
- Cookie：可以向服务器带数据。
- Content-Type：请求主体的内容是如何编码的。
- Content-Length：请求主体的字节数。
- Host：请求的服务器主机名。
- Referer：当前请求来自哪里。（直接访问不存在这个头，一般用于防盗链）
- User-Agent：客户端浏览器与操作系统相关信息。
- Connection：保持连接状态。Keep-Alive连接中，close已关闭。

**3、响应首部（响应头）：**出现在响应报文第一行的后面，提供了一些关于响应报文的一些信息

- Location：指定响应的路径，配合302状态码使用。
- Content-Type：返回的内容的类型，比如text/html;charset=UTF-8。
- Date：返回响应的时间
- Set-Cookie：设置与页面关联的Cookie
- Content-Encoding：文档的编码（Encode）类型。
- Content-Length：响应正文的长度。
- Content-Disposition：通过浏览器以下载的方式打开数据。
- Refresh：刷新时间+路径。
- Server：服务器名字。

**4、实体首部：**我们都知道，请求报文和响应报文都包含实体报文，实体首部就是用来描述实体报文的一些属性。

**5、扩展头部：**HTTP规范中没有定义的首部。

#### HTTP方法

- GET：获取资源
- POST：传输实体主体
- PUT：传输文件
- HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。
- DELETE：删除文件，与PUT相反（响应返回204 No Content）
- OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法（Allow:GET、POST、HEAD、OPTIONS）

##### GET 和 POST 的区别

1. GET 方式的参数以查询字符串的形式出现在 URL 中；POST 方式的参数则存储在请求体中
2. GET URL长度有限制，POST没有限制
3. 由于 URL 只支持 ASCII 码，因此如果 GET 参数出现中文等字符就需要进行百分号编码转换； POST 支持标准字符集
4. GET 请求可以被收藏为书签，POST 不可以
5. GET 是具有幂等性，而 POST 不具有幂等性

> 幂等性指的是，同样的请求被执行一次与连续执行多次的效果是一样的， 服务器的状态也是一样的
>
> 在正确实现的条件下，GET、PUT、DELETE 等方法都是幂等的，而 POST 不是
>
> 两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI，所以POST方法不具备幂等性

#### HTTP状态码

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出           |

##### 1xx 信息

- **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

##### 2xx 请求正常处理完毕

- **200 OK**：客户端发来的请求在服务器端被正常处理。
- **204 No Content** ：服务器接收的请求已成功处理，但==无资源可返回==。一般只需要从客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况下使用。
- **206 Partial Content** ：表示==客户端==进行了==范围请求==，而==服务器==成功执行了这部分的==GET请求==。

##### 3xx 重定向

- **301 Moved Permanently** ：==永久重定向==，请求的资源已被分配新的URL，==以后==应使用资源现在所指的URL。
- **302 Found** ：临时重定向，请求的资源已被分配新的URL，希望用户==本次==使用新的URL。
- **303 See Other** ：由于请求对应的资源存在着另一个URL，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问。
- **304 Not Modified** ：客户端发送附带条件的请求（GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）时，服务器端允许请求访问资源，但请求未满足条件。（304其实与重定向没有关系。）
- **307 Temporary Redirect** ：临时重定向，但请求方式不会从POST变为GET。

##### 4xx 客户端错误

- **400 Bad Request** ：==请求报文中存在语法错误==。
- **401 Unauthorized** ：发送的请求需有通过HTTP认证的认证信息。
- **403 Forbidden** ：对请求资源的访问==被服务器拒绝了==。
- **404 Not Found**：请求资源不存在。
- **499 Client Closed Request**：服务端响应时间过长，客户端主动断开连接。

##### 5xx 服务器错误

- **500 Internal Server Error** ：服务器正在执行请求时发生错误。
- **502 Bad Gateway**：网关错误。502已经与后端建立了连接，但接口程序执行超时。
- **503 Service Unavailable** ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
- **504 Gateway Timeout**：网关超时。504与后端未建立连接，超时。

#### HTTP 协议各版本

> HTTP 1.0：短连接——单工 客户端发起请求之后，服务端处理完请求并收到客户端的响应后即断开连接。
>
> HTTP 1.1：Keep-Alive——长连接——半双工 如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。
>
> HTTP 2.0：多路复用——全双工——允许服务端主动向客户端发送数据 一个 TCP 连接中 HTTP 请求发送可以一起发送

##### HTTP 1.1 和 HTTP 1.0 的区别

1. HTTP 1.0 默认使用短连接，客户端和服务器每次进行一次 HTTP 请求都需要新建一个 TCP 连接，任务结束就中断连接。

   HTTP 1.1 支持长连接和请求流水线处理，一个 TCP 连接上可以传输多个 HTTP 请求和响应，减少了建立和关闭连接的开销。

   HTTP 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；HTTP 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。

2. HTTP1.1引入 HOST 请求头。在 HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。

3. 错误通知管理 ：HTTP 1.1 新增了 24 个错误状态响应码。如 410 表示请求资源被永久删除。

4. 缓存处理：HTTP 1.1 在请求头引入更多和缓存相关的参数，以此来更灵活的支持缓存。

5. 节约带宽：HTTP 1.0 客户端在请求某个资源时，默认服务端将整个资源返回客户端。但很多时候客户端并不一定需要所有信息。HTTP 1.1 请求头引入 range 参数，通过配置它实现请求部分实体数据。并且客户端可以采用多线程并发访问某资源的不同段，充分利用带宽资源。

6. 断点续传：利用HTTP消息头使用分块传输编码，将实体主体分块进行传输。

##### HTTP 2.0 和 HTTP 1.1 的区别

1. 解析格式 ：HTTP1.1 的解析是基于文本的；HTTP2.0 的解析是二进制格式的，方便简单且鲁棒性高
2. 多路复用 ：HTTP1.1 中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过该数量的请求将会被阻塞；HTTP2.0 的多路复用则运行通过单一的连接发起多个请求-响应消息
3. header 压缩：HTTP1.1 的 header 可能会携带大量信息且每次连接都要带上；HTTP2.0 通过使用哈夫曼编码减少需要传输的 header 大小，通讯双方各自缓存一份 header 字段表，避免了 header 的重复传输，也减小了 header 的大小
4. 服务端推送 ：HTTP2.0 支持在客户端请求一个资源的同时将相关资源一起发送给客户端，同时在同源情况下，不同页面之间可以共享缓存资源

##### HTTP 3.0

HTTP 3.0和之间HTTP 1.x或HTTP 2.0的最大区别就是，它是基于UDP的，而以前的都是基于TCP的；使用UDP能减少RTT（往返时延）

#### HTTP优化方案

**TCP复用**：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。

**内容缓存**：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。

**压缩**：将文本数据进行压缩，减少带宽

**SSL加速**：使用SSL协议对HTTP协议进行加密，在通道内加密并加速

**TCP缓冲**：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。

#### HTTP与WebSocket的区别

**相同点：**

1. 都是基于tcp的，都是可靠性传输协议
2. 都是应用层协议

**不同点：**

1. **WebSocket是全双工（双向通信）协议，可以双向发送或接受信息**
2. **http本质还是一个半双工协议**
3. **WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的**

### HTTPS

HTTPS 主要对 HTTP 中**容易遭受攻击**的缺点进行了改进，主要有三点 ( 所有信息明文传播都有这些缺点 )

- HTTP 通信使用明文不加密，内容可能会**被窃听**，通过**加密解决**
- HTTP 不验证通信方的身份，因此可能**遭遇伪装**，通过**认证解决**
- HTTP 无法验证报文是否被篡改，所以有可能收到的报文已经遭**受到篡改**，通过**完整性保护解决**

==HTTPS = HTTP + 加密 + 认证 + 完整性保护==

HTTPS 的本质其实是先和 SSL 进行通信，再由 SSL 和 TCP 进行通信。

#### TLS四次握手（非对称加密）

HTTPS 首次通信需要 7 次握手（==TCP 三次握手 + TLS 四次握手==）。

先进行 TCP 三次握手再进行 TLS 四次握手。

首先**第一次握手**客户端会向服务端发送client hello信息，告诉服务端需要的tls版本信息，支持的加密算法有哪些，这些算法组成加密套件，然后是一个随机数。

然后**第二次握手**服务端向客户端发送一个Server hello，然后告诉客户端服务端支持的确认支持的tls版本以及选择的加密套件，也会生成一个随机数告诉客户端，然后服务器出示一个证书，这样浏览器可以根据自己信任的证书列表来确认这个证书服务器是否可信，然后把公钥给客户端，再发后一个结束信号，Server Hello Done。

**第三次握手**会使用公钥加密生成预主密钥给服务端，服务端使用私钥解密，接下来使用预祝密钥和前两个随机数组成最终的密钥进行密钥通信。

**第四次握手**服务端发送一个信号对客户端进行确认，加密通信开始。

总结：握手时客户端先发送**支持的协议版本、加密套件和随机数**（Client Random）；服务端回应**选定的套件、自己的随机数（Server Random）和证书（含公钥）**；客户端验证证书合法后，生成**预主密钥**（Pre-Master Secret），用服务端公钥加密并发送；**双方基于三个随机数（Client Random、Server Random、Pre-Master Secret）独立派生出相同的**会话密钥，后续通信通过对称加密（如 AES）进行。

#### 对称加密和非对称加密

对称加密：一份密钥

非对称加密：公钥+密钥

#### HTTPS请求过程

HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，其中数据传输阶段又可以分为**非对称加密（用于密钥交换）**和**对称加密（用于实际数据传输）**两个阶段。

1. 客户端向服务器的443端口发送https请求。
2. 服务端向CA机构获取证书。颁发证书的同时会产生一个私钥和公钥。
3. 服务器响应客户端请求，将证书发送给客户端，证书包含公钥。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。
5. 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。
6. 服务器使用私钥讲随机码 KEY 进行解密，获得密钥。
7. 服务器使用密钥 KEY 对数据进行对称加密并发送给客户端，客户端使用相同的密钥 KEY 解密数据。
8. 双方使用对称加密愉快地传输所有数据。

#### HTTPS中数字认证流程

https://www.cnblogs.com/fengf233/p/11775415.html

由于公钥在下发的时候也容易被替换劫持，所以需要个第三方认证机构==确认公钥的安全性==。

CA：数字证书认证机构，是客户端服务端都认可的第三方机构，负责数字签名服务端公钥

数字签名：签名就是一种证明身份的机制，是一种校验机制（简单说是用私钥加密内容的hash,公钥解密对比hash判断内容是否完整）

数字证书：由一个可信的组织验证和签发的识别信息

### HTTP、HTTPS的区别

1. http是数据传输是明文的，是不安全的；https是使用了SSL/TSL协议加密的安全传输
2. http的端口默认是80，https的端口默认是443
3. http是无状态的连接，https是ssl加密的传输，身份认证的网络协议。
4. http的 URL 前缀是 `http://`，https的 URL 前缀是 `https://`
5. https比http耗费更多服务器资源
6. https协议要CA证书申请

## TCP/IP 和 HTTP 的关系

https://mp.weixin.qq.com/s/TMe5QsBL6t6YPt_vLHNZ6w

HTTP是一种应用层协议，TCP是一种面向连接的、可靠的传输层协议，IP是一种网络层协议。

如果把TCP/IP看做一个整体，**TCP/IP可以比喻成快递/物流公司**，**HTTP可以比喻成发送/接收快递的用户**。**他们是什么关系？服务与被服务的关系！**TCP/IP可以帮助HTTP用户，将包裹安全可靠送达目的地。

在TCP/IP快递公司内部，有进一步的分工，**TCP是公司管理层，坐在物流调度室里负责调度。IP是公司具体干活的——卡车司机**，TCP调度员让IP司机把货送到哪里就送到哪里，一切听命行事。

HTTP使用TCP作为其传输层协议来确保传输的可靠性和完整性。TCP提供的可靠性保证了HTTP请求和响应消息能够在网络上正确地传输。